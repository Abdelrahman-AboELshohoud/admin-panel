type Point {
  lat: Float!
  lng: Float!
  heading: Int
}

type DistanceMultiplier {
  distanceFrom: Float!
  distanceTo: Float!
  multiply: Float!
}

type TimeMultiplier {
  startTime: String!
  endTime: String!
  multiply: Float!
}

type ExportResult {
  url: String!
}

type IncomeResultItem {
  time: String!
  sum: Float!
  currency: String!
}

type RegistrationResultItem {
  count: Int!
  time: String!
}

type RequestResultItem {
  time: String!
  count: Float!
  status: OrderStatus!
}

enum OrderStatus {
  Requested
  NotFound
  NoCloseFound
  Found
  DriverAccepted
  Arrived
  WaitingForPrePay
  DriverCanceled
  RiderCanceled
  Started
  WaitingForPostPay
  WaitingForReview
  Finished
  Booked
  Expired
}

type ProviderTransaction {
  id: ID!
  action: TransactionAction!
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  createdAt: DateTime!
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
}

enum TransactionAction {
  Recharge
  Deduct
}

enum ProviderDeductTransactionType {
  Withdraw
}

enum ProviderRechargeTransactionType {
  Commission
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type ProviderWallet {
  id: ID!
  balance: Float!
  currency: String!
}

type DeleteManyResponse {
  # The number of records deleted.
  deletedCount: Int!
}

type UpdateManyResponse {
  # The number of records updated.
  updatedCount: Int!
}

type OffsetPageInfo {
  # true if paging forward and there are more records.
  hasNextPage: Boolean

  # true if paging backwards and there are more records.
  hasPreviousPage: Boolean
}

type ProviderTransactionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [ProviderTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type Address {
  id: ID!
  riderId: ID!
  title: String!
  type: RiderAddressType!
  details: String
  location: Point!
}

enum RiderAddressType {
  Home
  Work
  Partner
  Gym
  Parent
  Cafe
  Park
  Other
}

type AddressEdge {
  # The node containing the Address
  node: Address!

  # Cursor for this node.
  cursor: ConnectionCursor!
}

# Cursor for paging through collections
scalar ConnectionCursor

type PageInfo {
  # true if paging forward and there are more records.
  hasNextPage: Boolean

  # true if paging backwards and there are more records.
  hasPreviousPage: Boolean

  # The cursor of the first returned record.
  startCursor: ConnectionCursor

  # The cursor of the last returned record.
  endCursor: ConnectionCursor
}

type AddressConnection {
  # Paging information
  pageInfo: PageInfo!

  # Array of edges.
  edges: [AddressEdge!]!
}

type Announcement {
  id: ID!
  title: String!
  description: String!
  url: String
  userType: [AnnouncementUserType!]!
  startAt: DateTime!
  expireAt: DateTime!
}

enum AnnouncementUserType {
  Driver
  Rider
  Operator
}

type AnnouncementDeleteResponse {
  id: ID
  title: String
  description: String
  url: String
  userType: [AnnouncementUserType!]
  startAt: DateTime
  expireAt: DateTime
}

type AnnouncementConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Announcement!]!

  # Fetch total count of records
  totalCount: Int!
}

type CarColor {
  id: ID!
  name: String!
}

type CarModel {
  id: ID!
  name: String!
}

type CarModelDeleteResponse {
  id: ID
  name: String
}

type CarModelConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [CarModel!]!

  # Fetch total count of records
  totalCount: Int!
}

type CarColorDeleteResponse {
  id: ID
  name: String
}

type WeekdayMultiplier {
  weekday: Weekday!
  multiply: Float!
}

enum Weekday {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}

type DateRangeMultiplier {
  startDate: Float!
  endDate: Float!
  multiply: Float!
}

type Region {
  id: ID!
  currency: String!
  name: String!
  enabled: Boolean!
  location: [[Point!]!]!
}

type Media {
  id: ID!
  address: String!
  base64: String
}

type ServiceOption {
  id: ID!
  name: String!
  type: ServiceOptionType!
  additionalFee: Float
  icon: ServiceOptionIcon!
}

enum ServiceOptionType {
  Free
  Paid
  TwoWay
}

enum ServiceOptionIcon {
  Pet
  TwoWay
  Luggage
  PackageDelivery
  Shopping
  Custom1
  Custom2
  Custom3
  Custom4
  Custom5
}

type Service {
  id: ID!
  personCapacity: Int
  categoryId: ID!
  searchRadius: Int!
  providerSharePercent: Int!
  maximumDestinationDistance: Int!
  mediaId: ID!
  name: String!
  description: String
  baseFare: Float!
  roundingFactor: Float
  perHundredMeters: Float!
  perMinuteDrive: Float!
  perMinuteWait: Float!
  prepayPercent: Float!
  minimumFee: Float!
  paymentMethod: ServicePaymentMethod!
  cancellationTotalFee: Float!
  cancellationDriverShare: Float!
  providerShareFlat: Float!
  twoWayAvailable: Boolean!
  timeMultipliers: [TimeMultiplier!]!
  distanceMultipliers: [DistanceMultiplier!]!
  weekdayMultipliers: [WeekdayMultiplier!]!
  dateRangeMultipliers: [DateRangeMultiplier!]!
  media: Media!
  regions(
    # Specify to filter the records returned.
    filter: RegionFilter! = {}

    # Specify to sort results.
    sorting: [RegionSort!]! = []
  ): [Region!]!
  options(
    # Specify to filter the records returned.
    filter: ServiceOptionFilter! = {}

    # Specify to sort results.
    sorting: [ServiceOptionSort!]! = []
  ): [ServiceOption!]!
}

enum ServicePaymentMethod {
  CashCredit
  OnlyCredit
  OnlyCash
}

input RegionFilter {
  and: [RegionFilter!]
  or: [RegionFilter!]
  id: IDFilterComparison
  currency: StringFieldComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input RegionSort {
  field: RegionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RegionSortFields {
  id
  currency
}

# Sort Directions
enum SortDirection {
  ASC
  DESC
}

# Sort Nulls Options
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input ServiceOptionFilter {
  and: [ServiceOptionFilter!]
  or: [ServiceOptionFilter!]
  id: IDFilterComparison
}

input ServiceOptionSort {
  field: ServiceOptionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceOptionSortFields {
  id
}

type Coupon {
  id: ID!
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  discountPercent: Int!
  discountFlat: Int!
  code: String!
  title: String!
  description: String!
  minimumCost: Float!
  maximumCost: Float!
  startAt: DateTime!
  expireAt: DateTime!
  creditGift: Float!
  isEnabled: Boolean!
  isFirstTravelOnly: Boolean!
  allowedServices(
    # Specify to filter the records returned.
    filter: ServiceFilter! = {}

    # Specify to sort results.
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

input ServiceFilter {
  and: [ServiceFilter!]
  or: [ServiceFilter!]
  id: IDFilterComparison
  categoryId: IDFilterComparison
}

input ServiceSort {
  field: ServiceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceSortFields {
  id
  categoryId
}

type CouponDeleteResponse {
  id: ID
  manyUsersCanUse: Int
  manyTimesUserCanUse: Int
  discountPercent: Int
  discountFlat: Int
  code: String
  title: String
  description: String
  minimumCost: Float
  maximumCost: Float
  startAt: DateTime
  expireAt: DateTime
  creditGift: Float
  isEnabled: Boolean
  isFirstTravelOnly: Boolean
}

type CouponConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Coupon!]!

  # Fetch total count of records
  totalCount: Int!
}

type OnlineDriver {
  location: Point!
  driverId: Float!
  lastUpdatedAt: Float!
}

type OnlineDriverWithData {
  id: Float!
  location: Point!
  lastUpdatedAt: Float!
  firstName: String
  lastName: String
  mobileNumber: String!
  status: DriverStatus!
  gender: Gender
  rating: Float
  reviewCount: Float!
}

enum DriverStatus {
  Online
  Offline
  Blocked
  InService
  WaitingDocuments
  PendingApproval
  SoftReject
  HardReject
}

enum Gender {
  Male
  Female
  Unknown
}

type FeedbackParameter {
  id: ID!
  title: String!
  isGood: Boolean!
}

type Feedback {
  id: ID!
  score: Int!
  driverId: ID!
  requestId: ID!
  reviewTimestamp: DateTime!
  description: String
  parametersAggregate(
    # Filter to find records to aggregate on
    filter: FeedbackParameterAggregateFilter
  ): [FeedbackParametersAggregateResponse!]!
  parameters(
    # Specify to filter the records returned.
    filter: FeedbackParameterFilter! = {}

    # Specify to sort results.
    sorting: [FeedbackParameterSort!]! = []
  ): [FeedbackParameter!]!
}

input FeedbackParameterAggregateFilter {
  and: [FeedbackParameterAggregateFilter!]
  or: [FeedbackParameterAggregateFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input FeedbackParameterFilter {
  and: [FeedbackParameterFilter!]
  or: [FeedbackParameterFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input FeedbackParameterSort {
  field: FeedbackParameterSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FeedbackParameterSortFields {
  id
  title
  isGood
}

type OperatorRole {
  id: ID!
  title: String!
  permissions: [OperatorPermission!]!
}

enum OperatorPermission {
  Drivers_View
  Drivers_Edit
  Riders_View
  Riders_Edit
  Regions_View
  Regions_Edit
  Services_View
  Services_Edit
  Complaints_View
  Complaints_Edit
  Coupons_View
  Coupons_Edit
  Announcements_View
  Announcements_Edit
  Requests_View
  Fleets_View
  Fleets_Edit
  Gateways_View
  Gateways_Edit
  Users_View
  Users_Edit
  Cars_View
  Cars_Edit
  FleetWallet_View
  FleetWallet_Edit
  ProviderWallet_View
  ProviderWallet_Edit
  DriverWallet_View
  DriverWallet_Edit
  RiderWallet_View
  RiderWallet_Edit
  ReviewParameter_Edit
  Payouts_View
  Payouts_Edit
  GiftBatch_View
  GiftBatch_Create
  GiftBatch_ViewCodes
  SMSProviders_View
  SMSProviders_Edit
}

type Operator {
  id: ID!
  roleId: ID
  firstName: String
  lastName: String
  userName: String!
  mobileNumber: String
  email: String
  role: OperatorRole
}

type ComplaintActivity {
  id: ID!
  complaintId: ID!
  type: ComplaintActivityType!
  comment: String
  actor: Operator!
  assignedTo: Operator
}

enum ComplaintActivityType {
  AssignToOperator
  Update
  Resolved
}

type Complaint {
  id: ID!
  status: ComplaintStatus!
  requestId: ID!
  inscriptionTimestamp: DateTime!
  requestedByDriver: Boolean!
  subject: String!
  content: String
  activitiesAggregate(
    # Filter to find records to aggregate on
    filter: ComplaintActivityAggregateFilter
  ): [ComplaintActivitiesAggregateResponse!]!
  order: Order!
  activities(
    # Specify to filter the records returned.
    filter: ComplaintActivityFilter! = {}

    # Specify to sort results.
    sorting: [ComplaintActivitySort!]! = []
  ): [ComplaintActivity!]!
}

enum ComplaintStatus {
  Submitted
  UnderInvestigation
  Resolved
}

input ComplaintActivityAggregateFilter {
  and: [ComplaintActivityAggregateFilter!]
  or: [ComplaintActivityAggregateFilter!]
  id: IDFilterComparison
  complaintId: IDFilterComparison
}

input ComplaintActivityFilter {
  and: [ComplaintActivityFilter!]
  or: [ComplaintActivityFilter!]
  id: IDFilterComparison
  complaintId: IDFilterComparison
}

input ComplaintActivitySort {
  field: ComplaintActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ComplaintActivitySortFields {
  id
  complaintId
}

type PaymentGateway {
  id: ID!
  publicKey: String
  privateKey: String!
  merchantId: String
  saltKey: String
  enabled: Boolean!
  title: String!
  type: PaymentGatewayType!
  mediaId: Float
  media: Media
}

enum PaymentGatewayType {
  Stripe
  BrainTree
  PayPal
  Paytm
  Razorpay
  Paystack
  PayU
  Instamojo
  Flutterwave
  PayGate
  MIPS
  MercadoPago
  AmazonPaymentServices
  MyTMoney
  WayForPay
  MyFatoorah
  SberBank
  BinancePay
  OpenPix
  PayTR
  CustomLink
}

type PayoutMethod {
  id: ID!
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: String
  mediaId: ID
  balance: Float
  enabled: Boolean!
  currency: String!
  name: String!
  description: String
  type: PayoutMethodType!
  media: Media
  driverTransactions: DriverTransaction!
}

# The type of payout method
enum PayoutMethodType {
  Stripe
  BankTransfer
}

type PayoutAccount {
  id: ID!
  isDefault: Boolean!
  name: String!
  type: SavedPaymentMethodType!
  last4: String!
  currency: String!
  payoutMethodId: Float!
  accountNumber: String
  routingNumber: String
  accountHolderName: String
  bankName: String
  branchName: String
  accountHolderAddress: String
  accountHolderCity: String
  accountHolderState: String
  accountHolderZip: String
  accountHolderCountry: String
  accountHolderPhone: String
  accountHolderDateOfBirth: DateTime
  isVerified: Boolean!
  payoutMethod: PayoutMethod!
}

# Saved payment method type
enum SavedPaymentMethodType {
  CARD
  BANK_ACCOUNT
}

type DriverTransaction {
  id: ID!
  createdAt: DateTime!
  status: TransactionStatus!
  amount: Float!
  driverId: ID!
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  operatorId: ID
  action: TransactionAction!
  deductType: DriverDeductTransactionType
  rechargeType: DriverRechargeTransactionType
  currency: String!
  refrenceNumber: String
  requestId: Float
  description: String
  operator: Operator
  driver: Driver
  payoutAccount: PayoutAccount
}

enum TransactionStatus {
  Processing
  Done
  Canceled
  Rejected
}

enum DriverDeductTransactionType {
  Withdraw
  Commission
  Correction
}

enum DriverRechargeTransactionType {
  OrderFee
  BankTransfer
  InAppPayment
  Gift
}

type FleetTransaction {
  id: ID!
  operatorId: ID
  requestId: ID
  fleetId: ID!
  transactionTimestamp: DateTime!
  action: TransactionAction!
  deductType: String
  rechargeType: String
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  operator: Operator
}

type RiderAddress {
  id: ID!
  riderId: ID!
  type: RiderAddressType!
  title: String!
  details: String
  location: Point!
}

type RiderWallet {
  id: ID!
  balance: Float!
  riderId: ID
  currency: String!
  rider: Rider
}

type Rider {
  id: ID!
  firstName: String
  lastName: String
  mobileNumber: String!
  gender: Gender
  status: RiderStatus!
  registrationTimestamp: DateTime!
  email: String
  isResident: Boolean
  idNumber: String
  media: Media
  addresses(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderAddressFilter! = {}

    # Specify to sort results.
    sorting: [RiderAddressSort!]! = []
  ): RiderAddressesConnection!
  wallets(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderWalletFilter! = {}

    # Specify to sort results.
    sorting: [RiderWalletSort!]! = []
  ): RiderWalletsConnection!
  transactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderTransactionFilter! = {}

    # Specify to sort results.
    sorting: [RiderTransactionSort!]! = []
  ): RiderTransactionsConnection!
  orders(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: OrderFilter! = {}

    # Specify to sort results.
    sorting: [OrderSort!]! = []
  ): RiderOrdersConnection!
}

enum RiderStatus {
  Enabled
  Disabled
}

input OffsetPaging {
  # Limit the number of records returned
  limit: Int

  # Offset to start returning records from
  offset: Int
}

input RiderAddressFilter {
  and: [RiderAddressFilter!]
  or: [RiderAddressFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input RiderAddressSort {
  field: RiderAddressSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderAddressSortFields {
  id
  riderId
}

input RiderWalletFilter {
  and: [RiderWalletFilter!]
  or: [RiderWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  riderId: IDFilterComparison
}

input FloatFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: FloatFieldComparisonBetween
  notBetween: FloatFieldComparisonBetween
}

input FloatFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input RiderWalletSort {
  field: RiderWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderWalletSortFields {
  id
  balance
  riderId
}

input RiderTransactionFilter {
  and: [RiderTransactionFilter!]
  or: [RiderTransactionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  amount: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

input RiderTransactionSort {
  field: RiderTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderTransactionSortFields {
  id
  createdAt
  amount
  currency
  riderId
}

input OrderFilter {
  and: [OrderFilter!]
  or: [OrderFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  riderId: IDFilterComparison
  driverId: IDFilterComparison
}

input OrderStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: OrderStatus
  neq: OrderStatus
  gt: OrderStatus
  gte: OrderStatus
  lt: OrderStatus
  lte: OrderStatus
  like: OrderStatus
  notLike: OrderStatus
  iLike: OrderStatus
  notILike: OrderStatus
  in: [OrderStatus!]
  notIn: [OrderStatus!]
}

input OrderSort {
  field: OrderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderSortFields {
  id
  createdOn
  status
  riderId
  driverId
}

type RiderTransaction {
  id: ID!
  createdAt: DateTime!
  amount: Float!
  currency: String!
  riderId: ID!
  paymentGatewayId: ID
  operatorId: ID
  requestId: ID
  action: TransactionAction!
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus!
  refrenceNumber: String
  description: String
  operator: Operator
  paymentGateway: PaymentGateway
  rider: Rider!
}

enum RiderDeductTransactionType {
  OrderFee
  ParkingFee
  CancellationFee
  Withdraw
  Correction
}

enum RiderRechargeTransactionType {
  BankTransfer
  Gift
  Correction
  InAppPayment
}

type OrderMessage {
  id: ID!
  sentAt: DateTime!
  sentByDriver: Boolean!
  status: MessageStatus!
  content: String!
}

enum MessageStatus {
  Sent
  Delivered
  Seen
}

type RequestActivity {
  id: ID!
  createdAt: DateTime!
  type: RequestActivityType!
}

enum RequestActivityType {
  RequestedByOperator
  BookedByOperator
  RequestedByRider
  BookedByRider
  DriverAccepted
  ArrivedToPickupPoint
  CanceledByDriver
  CanceledByRider
  CanceledByOperator
  Started
  ArrivedToDestination
  Paid
  Reviewed
  Expired
}

type Order {
  id: ID!
  createdOn: DateTime!
  status: OrderStatus!
  distanceBest: Int!
  durationBest: Int!
  destinationArrivedTo: Int!
  riderId: ID!
  driverId: ID
  startTimestamp: DateTime
  finishTimestamp: DateTime
  costBest: Float!
  costAfterCoupon: Float!
  currency: String!
  waitMinutes: Float!
  addresses: [String!]!
  points: [Point!]!
  expectedTimestamp: DateTime
  complaintsAggregate(
    # Filter to find records to aggregate on
    filter: ComplaintAggregateFilter
  ): [OrderComplaintsAggregateResponse!]!
  conversationsAggregate(
    # Filter to find records to aggregate on
    filter: OrderMessageAggregateFilter
  ): [OrderConversationsAggregateResponse!]!
  riderTransactionsAggregate(
    # Filter to find records to aggregate on
    filter: RiderTransactionAggregateFilter
  ): [OrderRiderTransactionsAggregateResponse!]!
  driverTransactionsAggregate(
    # Filter to find records to aggregate on
    filter: DriverTransactionAggregateFilter
  ): [OrderDriverTransactionsAggregateResponse!]!
  fleetTransactionsAggregate(
    # Filter to find records to aggregate on
    filter: FleetTransactionAggregateFilter
  ): [OrderFleetTransactionsAggregateResponse!]!
  providerTransactionsAggregate(
    # Filter to find records to aggregate on
    filter: ProviderTransactionAggregateFilter
  ): [OrderProviderTransactionsAggregateResponse!]!
  activitiesAggregate(
    # Filter to find records to aggregate on
    filter: RequestActivityAggregateFilter
  ): [OrderActivitiesAggregateResponse!]!
  driver: Driver
  rider: Rider
  service: Service
  coupon: Coupon
  complaints(
    # Specify to filter the records returned.
    filter: ComplaintFilter! = {}

    # Specify to sort results.
    sorting: [ComplaintSort!]! = []
  ): [Complaint!]!
  conversations(
    # Specify to filter the records returned.
    filter: OrderMessageFilter! = {}

    # Specify to sort results.
    sorting: [OrderMessageSort!]! = []
  ): [OrderMessage!]!
  riderTransactions(
    # Specify to filter the records returned.
    filter: RiderTransactionFilter! = {}

    # Specify to sort results.
    sorting: [RiderTransactionSort!]! = []
  ): [RiderTransaction!]!
  driverTransactions(
    # Specify to filter the records returned.
    filter: DriverTransactionFilter! = {}

    # Specify to sort results.
    sorting: [DriverTransactionSort!]! = []
  ): [DriverTransaction!]!
  fleetTransactions(
    # Specify to filter the records returned.
    filter: FleetTransactionFilter! = {}

    # Specify to sort results.
    sorting: [FleetTransactionSort!]! = []
  ): [FleetTransaction!]!
  providerTransactions(
    # Specify to filter the records returned.
    filter: ProviderTransactionFilter! = {}

    # Specify to sort results.
    sorting: [ProviderTransactionSort!]! = []
  ): [ProviderTransaction!]!
  activities(
    # Specify to filter the records returned.
    filter: RequestActivityFilter! = {}

    # Specify to sort results.
    sorting: [RequestActivitySort!]! = []
  ): [RequestActivity!]!
}

input ComplaintAggregateFilter {
  and: [ComplaintAggregateFilter!]
  or: [ComplaintAggregateFilter!]
  id: IDFilterComparison
  status: ComplaintStatusFilterComparison
  requestId: IDFilterComparison
}

input ComplaintStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ComplaintStatus
  neq: ComplaintStatus
  gt: ComplaintStatus
  gte: ComplaintStatus
  lt: ComplaintStatus
  lte: ComplaintStatus
  like: ComplaintStatus
  notLike: ComplaintStatus
  iLike: ComplaintStatus
  notILike: ComplaintStatus
  in: [ComplaintStatus!]
  notIn: [ComplaintStatus!]
}

input OrderMessageAggregateFilter {
  and: [OrderMessageAggregateFilter!]
  or: [OrderMessageAggregateFilter!]
  id: IDFilterComparison
}

input RiderTransactionAggregateFilter {
  and: [RiderTransactionAggregateFilter!]
  or: [RiderTransactionAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  amount: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
}

input DriverTransactionAggregateFilter {
  and: [DriverTransactionAggregateFilter!]
  or: [DriverTransactionAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
}

input TransactionStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TransactionStatus
  neq: TransactionStatus
  gt: TransactionStatus
  gte: TransactionStatus
  lt: TransactionStatus
  lte: TransactionStatus
  like: TransactionStatus
  notLike: TransactionStatus
  iLike: TransactionStatus
  notILike: TransactionStatus
  in: [TransactionStatus!]
  notIn: [TransactionStatus!]
}

input NumberFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: NumberFieldComparisonBetween
  notBetween: NumberFieldComparisonBetween
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input FleetTransactionAggregateFilter {
  and: [FleetTransactionAggregateFilter!]
  or: [FleetTransactionAggregateFilter!]
  id: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  fleetId: IDFilterComparison
}

input ProviderTransactionAggregateFilter {
  and: [ProviderTransactionAggregateFilter!]
  or: [ProviderTransactionAggregateFilter!]
  id: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
}

input RequestActivityAggregateFilter {
  and: [RequestActivityAggregateFilter!]
  or: [RequestActivityAggregateFilter!]
  id: IDFilterComparison
}

input ComplaintFilter {
  and: [ComplaintFilter!]
  or: [ComplaintFilter!]
  id: IDFilterComparison
  status: ComplaintStatusFilterComparison
  requestId: IDFilterComparison
}

input ComplaintSort {
  field: ComplaintSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ComplaintSortFields {
  id
  status
  requestId
}

input OrderMessageFilter {
  and: [OrderMessageFilter!]
  or: [OrderMessageFilter!]
  id: IDFilterComparison
}

input OrderMessageSort {
  field: OrderMessageSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderMessageSortFields {
  id
}

input DriverTransactionFilter {
  and: [DriverTransactionFilter!]
  or: [DriverTransactionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
}

input DriverTransactionSort {
  field: DriverTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverTransactionSortFields {
  id
  createdAt
  status
  amount
  driverId
  paymentGatewayId
  payoutSessionId
  payoutAccountId
  payoutMethodId
}

input FleetTransactionFilter {
  and: [FleetTransactionFilter!]
  or: [FleetTransactionFilter!]
  id: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  fleetId: IDFilterComparison
}

input FleetTransactionSort {
  field: FleetTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetTransactionSortFields {
  id
  operatorId
  requestId
  fleetId
}

input ProviderTransactionFilter {
  and: [ProviderTransactionFilter!]
  or: [ProviderTransactionFilter!]
  id: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
}

input ProviderTransactionSort {
  field: ProviderTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProviderTransactionSortFields {
  id
  operatorId
  requestId
}

input RequestActivityFilter {
  and: [RequestActivityFilter!]
  or: [RequestActivityFilter!]
  id: IDFilterComparison
}

input RequestActivitySort {
  field: RequestActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RequestActivitySortFields {
  id
}

type Driver {
  id: ID!
  fleetId: ID
  lastName: String
  mobileNumber: String!
  carProductionYear: Int
  carId: ID
  carColorId: ID
  status: DriverStatus!
  mediaId: ID
  firstName: String
  certificateNumber: String
  email: String
  carPlate: String
  gender: Gender
  rating: Float
  reviewCount: Float!
  registrationTimestamp: DateTime!
  lastSeenTimestamp: DateTime
  accountNumber: String
  bankName: String
  bankRoutingNumber: String
  bankSwift: String
  address: String
  softRejectionNote: String
  feedbacksAggregate(
    # Filter to find records to aggregate on
    filter: FeedbackAggregateFilter
  ): [DriverFeedbacksAggregateResponse!]!
  walletsAggregate(
    # Filter to find records to aggregate on
    filter: DriverWalletAggregateFilter
  ): [DriverWalletsAggregateResponse!]!
  enabledServicesAggregate(
    # Filter to find records to aggregate on
    filter: ServiceAggregateFilter
  ): [DriverEnabledServicesAggregateResponse!]!
  documentsAggregate(
    # Filter to find records to aggregate on
    filter: MediaAggregateFilter
  ): [DriverDocumentsAggregateResponse!]!
  transactionsAggregate(
    # Filter to find records to aggregate on
    filter: DriverTransactionAggregateFilter
  ): [DriverTransactionsAggregateResponse!]!
  ordersAggregate(
    # Filter to find records to aggregate on
    filter: OrderAggregateFilter
  ): [DriverOrdersAggregateResponse!]!
  payoutAccountsAggregate(
    # Filter to find records to aggregate on
    filter: PayoutAccountAggregateFilter
  ): [DriverPayoutAccountsAggregateResponse!]!
  media: Media
  feedbacks(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FeedbackFilter! = {}

    # Specify to sort results.
    sorting: [FeedbackSort!]! = []
  ): DriverFeedbacksConnection!
  wallets(
    # Specify to filter the records returned.
    filter: DriverWalletFilter! = {}

    # Specify to sort results.
    sorting: [DriverWalletSort!]! = []
  ): [DriverWallet!]!
  enabledServices(
    # Specify to filter the records returned.
    filter: ServiceFilter! = {}

    # Specify to sort results.
    sorting: [ServiceSort!]! = []
  ): [Service!]!
  documents(
    # Specify to filter the records returned.
    filter: MediaFilter! = {}

    # Specify to sort results.
    sorting: [MediaSort!]! = []
  ): [Media!]!
  transactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DriverTransactionFilter! = {}

    # Specify to sort results.
    sorting: [DriverTransactionSort!]! = []
  ): DriverTransactionsConnection!
  orders(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: OrderFilter! = {}

    # Specify to sort results.
    sorting: [OrderSort!]! = []
  ): DriverOrdersConnection!
  payoutAccounts(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: PayoutAccountFilter! = {}

    # Specify to sort results.
    sorting: [PayoutAccountSort!]! = []
  ): DriverPayoutAccountsConnection!
}

input FeedbackAggregateFilter {
  and: [FeedbackAggregateFilter!]
  or: [FeedbackAggregateFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
  requestId: IDFilterComparison
  parameters: FeedbackAggregateFilterFeedbackParameterAggregateFilter
}

input FeedbackAggregateFilterFeedbackParameterAggregateFilter {
  and: [FeedbackAggregateFilterFeedbackParameterAggregateFilter!]
  or: [FeedbackAggregateFilterFeedbackParameterAggregateFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input DriverWalletAggregateFilter {
  and: [DriverWalletAggregateFilter!]
  or: [DriverWalletAggregateFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
}

input ServiceAggregateFilter {
  and: [ServiceAggregateFilter!]
  or: [ServiceAggregateFilter!]
  id: IDFilterComparison
  categoryId: IDFilterComparison
}

input MediaAggregateFilter {
  and: [MediaAggregateFilter!]
  or: [MediaAggregateFilter!]
  id: IDFilterComparison
}

input OrderAggregateFilter {
  and: [OrderAggregateFilter!]
  or: [OrderAggregateFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  riderId: IDFilterComparison
  driverId: IDFilterComparison
}

input PayoutAccountAggregateFilter {
  and: [PayoutAccountAggregateFilter!]
  or: [PayoutAccountAggregateFilter!]
  id: IDFilterComparison
  isDefault: BooleanFieldComparison
}

input FeedbackFilter {
  and: [FeedbackFilter!]
  or: [FeedbackFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
  requestId: IDFilterComparison
  parameters: FeedbackFilterFeedbackParameterFilter
}

input FeedbackFilterFeedbackParameterFilter {
  and: [FeedbackFilterFeedbackParameterFilter!]
  or: [FeedbackFilterFeedbackParameterFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input FeedbackSort {
  field: FeedbackSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FeedbackSortFields {
  id
  driverId
  requestId
}

input DriverWalletFilter {
  and: [DriverWalletFilter!]
  or: [DriverWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
}

input DriverWalletSort {
  field: DriverWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverWalletSortFields {
  id
  balance
  currency
  driverId
}

input MediaFilter {
  and: [MediaFilter!]
  or: [MediaFilter!]
  id: IDFilterComparison
}

input MediaSort {
  field: MediaSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum MediaSortFields {
  id
}

input PayoutAccountFilter {
  and: [PayoutAccountFilter!]
  or: [PayoutAccountFilter!]
  id: IDFilterComparison
  isDefault: BooleanFieldComparison
}

input PayoutAccountSort {
  field: PayoutAccountSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PayoutAccountSortFields {
  id
  isDefault
}

type DriverWallet {
  id: ID!
  balance: Float!
  currency: String!
  driverId: ID
  driver: Driver
}

type FeedbackParameterAggregate {
  count: ID!
  title: String!
  isGood: Boolean!
}

type DriverConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Driver!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverAggregateGroupBy {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  status: DriverStatus
}

type DriverCountAggregate {
  id: Int
  fleetId: Int
  lastName: Int
  mobileNumber: Int
  status: Int
}

type DriverSumAggregate {
  id: Float
  fleetId: Float
}

type DriverAvgAggregate {
  id: Float
  fleetId: Float
}

type DriverMinAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  status: DriverStatus
}

type DriverMaxAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  status: DriverStatus
}

type DriverAggregateResponse {
  groupBy: DriverAggregateGroupBy
  count: DriverCountAggregate
  sum: DriverSumAggregate
  avg: DriverAvgAggregate
  min: DriverMinAggregate
  max: DriverMaxAggregate
}

type DriverPayoutAccountsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [PayoutAccount!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverOrdersConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Order!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverTransactionsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [DriverTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverFeedbacksConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Feedback!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverPayoutAccountsAggregateGroupBy {
  id: ID
  isDefault: Boolean
}

type DriverPayoutAccountsCountAggregate {
  id: Int
  isDefault: Int
}

type DriverPayoutAccountsSumAggregate {
  id: Float
}

type DriverPayoutAccountsAvgAggregate {
  id: Float
}

type DriverPayoutAccountsMinAggregate {
  id: ID
}

type DriverPayoutAccountsMaxAggregate {
  id: ID
}

type DriverPayoutAccountsAggregateResponse {
  groupBy: DriverPayoutAccountsAggregateGroupBy
  count: DriverPayoutAccountsCountAggregate
  sum: DriverPayoutAccountsSumAggregate
  avg: DriverPayoutAccountsAvgAggregate
  min: DriverPayoutAccountsMinAggregate
  max: DriverPayoutAccountsMaxAggregate
}

type DriverOrdersAggregateGroupBy {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type DriverOrdersCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  riderId: Int
  driverId: Int
}

type DriverOrdersSumAggregate {
  id: Float
  riderId: Float
  driverId: Float
}

type DriverOrdersAvgAggregate {
  id: Float
  riderId: Float
  driverId: Float
}

type DriverOrdersMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type DriverOrdersMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type DriverOrdersAggregateResponse {
  groupBy: DriverOrdersAggregateGroupBy
  count: DriverOrdersCountAggregate
  sum: DriverOrdersSumAggregate
  avg: DriverOrdersAvgAggregate
  min: DriverOrdersMinAggregate
  max: DriverOrdersMaxAggregate
}

type DriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type DriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  status: Int
  amount: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
}

type DriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type DriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type DriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type DriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type DriverTransactionsAggregateResponse {
  groupBy: DriverTransactionsAggregateGroupBy
  count: DriverTransactionsCountAggregate
  sum: DriverTransactionsSumAggregate
  avg: DriverTransactionsAvgAggregate
  min: DriverTransactionsMinAggregate
  max: DriverTransactionsMaxAggregate
}

type DriverDocumentsAggregateGroupBy {
  id: ID
}

type DriverDocumentsCountAggregate {
  id: Int
}

type DriverDocumentsSumAggregate {
  id: Float
}

type DriverDocumentsAvgAggregate {
  id: Float
}

type DriverDocumentsMinAggregate {
  id: ID
}

type DriverDocumentsMaxAggregate {
  id: ID
}

type DriverDocumentsAggregateResponse {
  groupBy: DriverDocumentsAggregateGroupBy
  count: DriverDocumentsCountAggregate
  sum: DriverDocumentsSumAggregate
  avg: DriverDocumentsAvgAggregate
  min: DriverDocumentsMinAggregate
  max: DriverDocumentsMaxAggregate
}

type DriverEnabledServicesAggregateGroupBy {
  id: ID
  categoryId: ID
}

type DriverEnabledServicesCountAggregate {
  id: Int
  categoryId: Int
}

type DriverEnabledServicesSumAggregate {
  id: Float
  categoryId: Float
}

type DriverEnabledServicesAvgAggregate {
  id: Float
  categoryId: Float
}

type DriverEnabledServicesMinAggregate {
  id: ID
  categoryId: ID
}

type DriverEnabledServicesMaxAggregate {
  id: ID
  categoryId: ID
}

type DriverEnabledServicesAggregateResponse {
  groupBy: DriverEnabledServicesAggregateGroupBy
  count: DriverEnabledServicesCountAggregate
  sum: DriverEnabledServicesSumAggregate
  avg: DriverEnabledServicesAvgAggregate
  min: DriverEnabledServicesMinAggregate
  max: DriverEnabledServicesMaxAggregate
}

type DriverWalletsAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletsCountAggregate {
  id: Int
  balance: Int
  currency: Int
  driverId: Int
}

type DriverWalletsSumAggregate {
  id: Float
  balance: Float
  driverId: Float
}

type DriverWalletsAvgAggregate {
  id: Float
  balance: Float
  driverId: Float
}

type DriverWalletsMinAggregate {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletsMaxAggregate {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletsAggregateResponse {
  groupBy: DriverWalletsAggregateGroupBy
  count: DriverWalletsCountAggregate
  sum: DriverWalletsSumAggregate
  avg: DriverWalletsAvgAggregate
  min: DriverWalletsMinAggregate
  max: DriverWalletsMaxAggregate
}

type DriverFeedbacksAggregateGroupBy {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksCountAggregate {
  id: Int
  driverId: Int
  requestId: Int
}

type DriverFeedbacksSumAggregate {
  id: Float
  driverId: Float
  requestId: Float
}

type DriverFeedbacksAvgAggregate {
  id: Float
  driverId: Float
  requestId: Float
}

type DriverFeedbacksMinAggregate {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksMaxAggregate {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksAggregateResponse {
  groupBy: DriverFeedbacksAggregateGroupBy
  count: DriverFeedbacksCountAggregate
  sum: DriverFeedbacksSumAggregate
  avg: DriverFeedbacksAvgAggregate
  min: DriverFeedbacksMinAggregate
  max: DriverFeedbacksMaxAggregate
}

type DriverWalletConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [DriverWallet!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverTransactionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [DriverTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type DriverTransactionAggregateGroupBy {
  id: ID
  createdAt(by: GroupBy! = DAY): DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

# Group by
enum GroupBy {
  DAY
  WEEK
  MONTH
  YEAR
}

type DriverTransactionCountAggregate {
  id: Int
  createdAt: Int
  status: Int
  amount: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
}

type DriverTransactionSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type DriverTransactionAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type DriverTransactionMinAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type DriverTransactionMaxAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type DriverTransactionAggregateResponse {
  groupBy: DriverTransactionAggregateGroupBy
  count: DriverTransactionCountAggregate
  sum: DriverTransactionSumAggregate
  avg: DriverTransactionAvgAggregate
  min: DriverTransactionMinAggregate
  max: DriverTransactionMaxAggregate
}

type FeedbackConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Feedback!]!

  # Fetch total count of records
  totalCount: Int!
}

type FeedbackParametersAggregateGroupBy {
  id: ID
  title: String
  isGood: Boolean
}

type FeedbackParametersCountAggregate {
  id: Int
  title: Int
  isGood: Int
}

type FeedbackParametersSumAggregate {
  id: Float
}

type FeedbackParametersAvgAggregate {
  id: Float
}

type FeedbackParametersMinAggregate {
  id: ID
  title: String
}

type FeedbackParametersMaxAggregate {
  id: ID
  title: String
}

type FeedbackParametersAggregateResponse {
  groupBy: FeedbackParametersAggregateGroupBy
  count: FeedbackParametersCountAggregate
  sum: FeedbackParametersSumAggregate
  avg: FeedbackParametersAvgAggregate
  min: FeedbackParametersMinAggregate
  max: FeedbackParametersMaxAggregate
}

type FeedbackParameterDeleteResponse {
  id: ID
  title: String
  isGood: Boolean
}

type ZonePrice {
  id: ID!
  name: String!
  from: [[Point!]!]!
  to: [[Point!]!]!
  cost: Float!
  timeMultipliers: [TimeMultiplier!]!
  fleets(
    # Specify to filter the records returned.
    filter: FleetFilter! = {}

    # Specify to sort results.
    sorting: [FleetSort!]! = []
  ): [Fleet!]!
  services(
    # Specify to filter the records returned.
    filter: ServiceFilter! = {}

    # Specify to sort results.
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

input FleetFilter {
  and: [FleetFilter!]
  or: [FleetFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
}

input FleetSort {
  field: FleetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetSortFields {
  id
  name
}

type Fleet {
  id: ID!
  name: String!
  phoneNumber: String!
  mobileNumber: String!
  userName: String
  password: String
  accountNumber: String!
  commissionSharePercent: Float!
  commissionShareFlat: Float!
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[Point!]!]
  wallets(
    # Specify to filter the records returned.
    filter: FleetWalletFilter! = {}

    # Specify to sort results.
    sorting: [FleetWalletSort!]! = []
  ): [FleetWallet!]!
  transactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FleetTransactionFilter! = {}

    # Specify to sort results.
    sorting: [FleetTransactionSort!]! = []
  ): FleetTransactionsConnection!
  zonePrices(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: ZonePriceFilter! = {}

    # Specify to sort results.
    sorting: [ZonePriceSort!]! = []
  ): FleetZonePricesConnection!
}

input FleetWalletFilter {
  and: [FleetWalletFilter!]
  or: [FleetWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  fleetId: IDFilterComparison
}

input FleetWalletSort {
  field: FleetWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetWalletSortFields {
  id
  balance
  currency
  fleetId
}

input ZonePriceFilter {
  and: [ZonePriceFilter!]
  or: [ZonePriceFilter!]
  id: IDFilterComparison
}

input ZonePriceSort {
  field: ZonePriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ZonePriceSortFields {
  id
}

type FleetWallet {
  id: ID!
  balance: Float!
  currency: String!
  fleetId: ID!
  fleet: Fleet!
}

type FleetConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Fleet!]!

  # Fetch total count of records
  totalCount: Int!
}

type FleetZonePricesConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [ZonePrice!]!

  # Fetch total count of records
  totalCount: Int!
}

type FleetTransactionsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [FleetTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type FleetWalletConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [FleetWallet!]!

  # Fetch total count of records
  totalCount: Int!
}

type FleetTransactionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [FleetTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type OperatorConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Operator!]!

  # Fetch total count of records
  totalCount: Int!
}

type ServiceWithCost {
  id: ID!
  name: String!
  cost: Float!
  media: Media!
}

type ServiceCategoryWithCost {
  id: ID!
  name: String!
  services: [ServiceWithCost!]!
}

type CalculateFareDTO {
  currency: String!
  distance: Float!
  duration: Float!
  services: [ServiceCategoryWithCost!]!
  error: CalculateFareError
}

enum CalculateFareError {
  RegionUnsupported
  NoServiceInRegion
}

type OrderCancelReason {
  id: ID!
  title: String!
  isEnabled: Boolean!
  userType: AnnouncementUserType!
}

type OrderConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Order!]!

  # Fetch total count of records
  totalCount: Int!
}

type OrderAggregateGroupBy {
  id: ID
  createdOn(by: GroupBy! = DAY): DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type OrderCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  riderId: Int
  driverId: Int
}

type OrderSumAggregate {
  id: Float
  riderId: Float
  driverId: Float
}

type OrderAvgAggregate {
  id: Float
  riderId: Float
  driverId: Float
}

type OrderMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type OrderMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  riderId: ID
  driverId: ID
}

type OrderAggregateResponse {
  groupBy: OrderAggregateGroupBy
  count: OrderCountAggregate
  sum: OrderSumAggregate
  avg: OrderAvgAggregate
  min: OrderMinAggregate
  max: OrderMaxAggregate
}

type OrderActivitiesAggregateGroupBy {
  id: ID
}

type OrderActivitiesCountAggregate {
  id: Int
}

type OrderActivitiesSumAggregate {
  id: Float
}

type OrderActivitiesAvgAggregate {
  id: Float
}

type OrderActivitiesMinAggregate {
  id: ID
}

type OrderActivitiesMaxAggregate {
  id: ID
}

type OrderActivitiesAggregateResponse {
  groupBy: OrderActivitiesAggregateGroupBy
  count: OrderActivitiesCountAggregate
  sum: OrderActivitiesSumAggregate
  avg: OrderActivitiesAvgAggregate
  min: OrderActivitiesMinAggregate
  max: OrderActivitiesMaxAggregate
}

type OrderProviderTransactionsAggregateGroupBy {
  id: ID
  operatorId: ID
  requestId: ID
}

type OrderProviderTransactionsCountAggregate {
  id: Int
  operatorId: Int
  requestId: Int
}

type OrderProviderTransactionsSumAggregate {
  id: Float
  operatorId: Float
  requestId: Float
}

type OrderProviderTransactionsAvgAggregate {
  id: Float
  operatorId: Float
  requestId: Float
}

type OrderProviderTransactionsMinAggregate {
  id: ID
  operatorId: ID
  requestId: ID
}

type OrderProviderTransactionsMaxAggregate {
  id: ID
  operatorId: ID
  requestId: ID
}

type OrderProviderTransactionsAggregateResponse {
  groupBy: OrderProviderTransactionsAggregateGroupBy
  count: OrderProviderTransactionsCountAggregate
  sum: OrderProviderTransactionsSumAggregate
  avg: OrderProviderTransactionsAvgAggregate
  min: OrderProviderTransactionsMinAggregate
  max: OrderProviderTransactionsMaxAggregate
}

type OrderFleetTransactionsAggregateGroupBy {
  id: ID
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsCountAggregate {
  id: Int
  operatorId: Int
  requestId: Int
  fleetId: Int
}

type OrderFleetTransactionsSumAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type OrderFleetTransactionsAvgAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type OrderFleetTransactionsMinAggregate {
  id: ID
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsMaxAggregate {
  id: ID
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsAggregateResponse {
  groupBy: OrderFleetTransactionsAggregateGroupBy
  count: OrderFleetTransactionsCountAggregate
  sum: OrderFleetTransactionsSumAggregate
  avg: OrderFleetTransactionsAvgAggregate
  min: OrderFleetTransactionsMinAggregate
  max: OrderFleetTransactionsMaxAggregate
}

type OrderDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type OrderDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  status: Int
  amount: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
}

type OrderDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type OrderDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type OrderDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type OrderDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type OrderDriverTransactionsAggregateResponse {
  groupBy: OrderDriverTransactionsAggregateGroupBy
  count: OrderDriverTransactionsCountAggregate
  sum: OrderDriverTransactionsSumAggregate
  avg: OrderDriverTransactionsAvgAggregate
  min: OrderDriverTransactionsMinAggregate
  max: OrderDriverTransactionsMaxAggregate
}

type OrderRiderTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  amount: Float
  currency: String
  riderId: ID
}

type OrderRiderTransactionsCountAggregate {
  id: Int
  createdAt: Int
  amount: Int
  currency: Int
  riderId: Int
}

type OrderRiderTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
}

type OrderRiderTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
}

type OrderRiderTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  amount: Float
  currency: String
  riderId: ID
}

type OrderRiderTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  amount: Float
  currency: String
  riderId: ID
}

type OrderRiderTransactionsAggregateResponse {
  groupBy: OrderRiderTransactionsAggregateGroupBy
  count: OrderRiderTransactionsCountAggregate
  sum: OrderRiderTransactionsSumAggregate
  avg: OrderRiderTransactionsAvgAggregate
  min: OrderRiderTransactionsMinAggregate
  max: OrderRiderTransactionsMaxAggregate
}

type OrderConversationsAggregateGroupBy {
  id: ID
}

type OrderConversationsCountAggregate {
  id: Int
}

type OrderConversationsSumAggregate {
  id: Float
}

type OrderConversationsAvgAggregate {
  id: Float
}

type OrderConversationsMinAggregate {
  id: ID
}

type OrderConversationsMaxAggregate {
  id: ID
}

type OrderConversationsAggregateResponse {
  groupBy: OrderConversationsAggregateGroupBy
  count: OrderConversationsCountAggregate
  sum: OrderConversationsSumAggregate
  avg: OrderConversationsAvgAggregate
  min: OrderConversationsMinAggregate
  max: OrderConversationsMaxAggregate
}

type OrderComplaintsAggregateGroupBy {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsCountAggregate {
  id: Int
  status: Int
  requestId: Int
}

type OrderComplaintsSumAggregate {
  id: Float
  requestId: Float
}

type OrderComplaintsAvgAggregate {
  id: Float
  requestId: Float
}

type OrderComplaintsMinAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsMaxAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsAggregateResponse {
  groupBy: OrderComplaintsAggregateGroupBy
  count: OrderComplaintsCountAggregate
  sum: OrderComplaintsSumAggregate
  avg: OrderComplaintsAvgAggregate
  min: OrderComplaintsMinAggregate
  max: OrderComplaintsMaxAggregate
}

type OrderCancelReasonDeleteResponse {
  id: ID
  title: String
  isEnabled: Boolean
  userType: AnnouncementUserType
}

type OrderCancelReasonConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [OrderCancelReason!]!

  # Fetch total count of records
  totalCount: Int!
}

type PaymentGatewayConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [PaymentGateway!]!

  # Fetch total count of records
  totalCount: Int!
}

type RegionDeleteResponse {
  id: ID
  currency: String
  name: String
  enabled: Boolean
  location: [[Point!]!]
}

type RegionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Region!]!

  # Fetch total count of records
  totalCount: Int!
}

type RegionAggregateGroupBy {
  id: ID
  currency: String
}

type RegionCountAggregate {
  id: Int
  currency: Int
}

type RegionSumAggregate {
  id: Float
}

type RegionAvgAggregate {
  id: Float
}

type RegionMinAggregate {
  id: ID
  currency: String
}

type RegionMaxAggregate {
  id: ID
  currency: String
}

type RegionAggregateResponse {
  groupBy: RegionAggregateGroupBy
  count: RegionCountAggregate
  sum: RegionSumAggregate
  avg: RegionAvgAggregate
  min: RegionMinAggregate
  max: RegionMaxAggregate
}

type RiderConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Rider!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderOrdersConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Order!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderTransactionsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderWalletsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderWallet!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderAddressesConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderAddress!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderWalletConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderWallet!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderTransactionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type RiderAddressConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [RiderAddress!]!

  # Fetch total count of records
  totalCount: Int!
}

type ServiceCategory {
  id: ID!
  name: String!
  services(
    # Specify to filter the records returned.
    filter: ServiceFilter! = {}

    # Specify to sort results.
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

type ServiceDeleteResponse {
  id: ID
  personCapacity: Int
  categoryId: ID
  searchRadius: Int
  providerSharePercent: Int
  maximumDestinationDistance: Int
  mediaId: ID
  name: String
  description: String
  baseFare: Float
  roundingFactor: Float
  perHundredMeters: Float
  perMinuteDrive: Float
  perMinuteWait: Float
  prepayPercent: Float
  minimumFee: Float
  paymentMethod: ServicePaymentMethod
  cancellationTotalFee: Float
  cancellationDriverShare: Float
  providerShareFlat: Float
  twoWayAvailable: Boolean
  timeMultipliers: [TimeMultiplier!]
  distanceMultipliers: [DistanceMultiplier!]
  weekdayMultipliers: [WeekdayMultiplier!]
  dateRangeMultipliers: [DateRangeMultiplier!]
}

type ServiceCategoryDeleteResponse {
  id: ID
  name: String
}

type ServiceOptionDeleteResponse {
  id: ID
  name: String
  type: ServiceOptionType
  additionalFee: Float
  icon: ServiceOptionIcon
}

type ZonePriceDeleteResponse {
  id: ID
  name: String
  from: [[Point!]!]
  to: [[Point!]!]
  cost: Float
  timeMultipliers: [TimeMultiplier!]
}

type ZonePriceConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [ZonePrice!]!

  # Fetch total count of records
  totalCount: Int!
}

type TokenObject {
  token: String!
}

type MediaEdge {
  # The node containing the Media
  node: Media!

  # Cursor for this node.
  cursor: ConnectionCursor!
}

type ComplaintConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Complaint!]!

  # Fetch total count of records
  totalCount: Int!
}

type ComplaintAggregateGroupBy {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type ComplaintCountAggregate {
  id: Int
  status: Int
  requestId: Int
}

type ComplaintSumAggregate {
  id: Float
  requestId: Float
}

type ComplaintAvgAggregate {
  id: Float
  requestId: Float
}

type ComplaintMinAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type ComplaintMaxAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type ComplaintAggregateResponse {
  groupBy: ComplaintAggregateGroupBy
  count: ComplaintCountAggregate
  sum: ComplaintSumAggregate
  avg: ComplaintAvgAggregate
  min: ComplaintMinAggregate
  max: ComplaintMaxAggregate
}

type ComplaintActivitiesAggregateGroupBy {
  id: ID
  complaintId: ID
}

type ComplaintActivitiesCountAggregate {
  id: Int
  complaintId: Int
}

type ComplaintActivitiesSumAggregate {
  id: Float
  complaintId: Float
}

type ComplaintActivitiesAvgAggregate {
  id: Float
  complaintId: Float
}

type ComplaintActivitiesMinAggregate {
  id: ID
  complaintId: ID
}

type ComplaintActivitiesMaxAggregate {
  id: ID
  complaintId: ID
}

type ComplaintActivitiesAggregateResponse {
  groupBy: ComplaintActivitiesAggregateGroupBy
  count: ComplaintActivitiesCountAggregate
  sum: ComplaintActivitiesSumAggregate
  avg: ComplaintActivitiesAvgAggregate
  min: ComplaintActivitiesMinAggregate
  max: ComplaintActivitiesMaxAggregate
}

type LicenseInformation {
  buyerName: String!
  licenseType: LicenseType!
  supportExpireDate: DateTime!
  connectedApps: [AppType!]!
}

enum LicenseType {
  Regular
  Extended
  Bronze
  Silver
  Gold
}

enum AppType {
  Taxi
  Shop
  Parking
}

type AppConfigInfo {
  logo: String!
  name: String!
  color: String!
}

type CurrentConfiguration {
  taxi: AppConfigInfo
  shop: AppConfigInfo
  parking: AppConfigInfo
  purchaseCode: String
  backendMapsAPIKey: String
  adminPanelAPIKey: String
  firebaseProjectPrivateKey: String
  versionNumber: Float
  companyLogo: String
  companyName: String
  mysqlHost: String
  mysqlPort: String
  mysqlUser: String
  mysqlPassword: String
  mysqlDatabase: String
  redisHost: String
  redisPort: String
  redisPassword: String
}

type UpdatePurchaseCodeResult {
  status: UpdatePurchaseCodeStatus!
  message: String
  data: UpdatePurchaseCodeData
  clients: [UpdatePurchaseCodeClient!]
}

enum UpdatePurchaseCodeStatus {
  OK
  INVALID
  OVERUSED
  CLIENT_FOUND
}

type UpdatePurchaseCodeClient {
  id: Float!
  enabled: Float!
  ip: String!
  port: Float!
  token: String!
  purchase_id: Float!
  first_verified_at: String!
  last_verified_at: String!
}

type UpdatePurchaseCodeData {
  license: LicenseInformation!
  benefits: [String!]!
  drawbacks: [String!]!
  availableUpgrades: [AvaialbeUpgrade!]!
}

type AvaialbeUpgrade {
  type: String!
  price: Float!
  benefits: [String!]!
}

type UpdateConfigResult {
  status: UpdateConfigStatus!
  message: String
}

enum UpdateConfigStatus {
  OK
  INVALID
}

type ConfigInformation {
  isValid: Boolean!
  config: CurrentConfiguration
}

type SOSActivity {
  id: ID!
  createdAt: DateTime!
  action: SOSActivityAction!
  note: String
  operatorId: Float
  operator: Operator!
}

enum SOSActivityAction {
  Submitted
  Seen
  ContactDriver
  ContactAuthorities
  MarkedAsResolved
  MarkedAsFalseAlarm
}

type DistressSignal {
  id: ID!
  status: SOSStatus!
  createdAt: DateTime!
  location: Point
  submittedByRider: Boolean!
  requestId: Float!
  activitiesAggregate(
    # Filter to find records to aggregate on
    filter: SOSActivityAggregateFilter
  ): [DistressSignalActivitiesAggregateResponse!]!
  order: Order!
  activities(
    # Specify to filter the records returned.
    filter: SOSActivityFilter! = {}

    # Specify to sort results.
    sorting: [SOSActivitySort!]! = []
  ): [SOSActivity!]!
}

enum SOSStatus {
  Submitted
  UnderReview
  FalseAlarm
  Resolved
}

input SOSActivityAggregateFilter {
  and: [SOSActivityAggregateFilter!]
  or: [SOSActivityAggregateFilter!]
  id: IDFilterComparison
}

input SOSActivityFilter {
  and: [SOSActivityFilter!]
  or: [SOSActivityFilter!]
  id: IDFilterComparison
}

input SOSActivitySort {
  field: SOSActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SOSActivitySortFields {
  id
}

type DistressSignalConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [DistressSignal!]!

  # Fetch total count of records
  totalCount: Int!
}

type DistressSignalAggregateGroupBy {
  id: ID
  status: SOSStatus
}

type DistressSignalCountAggregate {
  id: Int
  status: Int
}

type DistressSignalSumAggregate {
  id: Float
}

type DistressSignalAvgAggregate {
  id: Float
}

type DistressSignalMinAggregate {
  id: ID
  status: SOSStatus
}

type DistressSignalMaxAggregate {
  id: ID
  status: SOSStatus
}

type DistressSignalAggregateResponse {
  groupBy: DistressSignalAggregateGroupBy
  count: DistressSignalCountAggregate
  sum: DistressSignalSumAggregate
  avg: DistressSignalAvgAggregate
  min: DistressSignalMinAggregate
  max: DistressSignalMaxAggregate
}

type DistressSignalActivitiesAggregateGroupBy {
  id: ID
}

type DistressSignalActivitiesCountAggregate {
  id: Int
}

type DistressSignalActivitiesSumAggregate {
  id: Float
}

type DistressSignalActivitiesAvgAggregate {
  id: Float
}

type DistressSignalActivitiesMinAggregate {
  id: ID
}

type DistressSignalActivitiesMaxAggregate {
  id: ID
}

type DistressSignalActivitiesAggregateResponse {
  groupBy: DistressSignalActivitiesAggregateGroupBy
  count: DistressSignalActivitiesCountAggregate
  sum: DistressSignalActivitiesSumAggregate
  avg: DistressSignalActivitiesAvgAggregate
  min: DistressSignalActivitiesMinAggregate
  max: DistressSignalActivitiesMaxAggregate
}

type Reward {
  id: ID!
  title: String!
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType!
  beneficiary: RewardBeneficiary!
  event: RewardEvent!
  creditGift: Float!
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

enum RewardAppType {
  Driver
  Rider
}

enum RewardBeneficiary {
  Self
  Referrer
}

enum RewardEvent {
  Register
  ServiceCompleted
}

type RewardDeleteResponse {
  id: ID
  title: String
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType
  beneficiary: RewardBeneficiary
  event: RewardEvent
  creditGift: Float
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

type RewardConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [Reward!]!

  # Fetch total count of records
  totalCount: Int!
}

type PayoutSession {
  id: ID!
  createdAt: DateTime!
  processedAt: DateTime
  description: String
  status: PayoutSessionStatus!
  totalAmount: Float!
  currency: String!
  driverTransactionsAggregate(
    # Filter to find records to aggregate on
    filter: DriverTransactionAggregateFilter
  ): [PayoutSessionDriverTransactionsAggregateResponse!]!
  driverTransactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DriverTransactionFilter! = {}

    # Specify to sort results.
    sorting: [DriverTransactionSort!]! = []
  ): PayoutSessionDriverTransactionsConnection!
  payoutMethods(
    # Specify to filter the records returned.
    filter: PayoutMethodFilter! = {}

    # Specify to sort results.
    sorting: [PayoutMethodSort!]! = []
  ): [PayoutMethod!]!
}

enum PayoutSessionStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

input PayoutMethodFilter {
  and: [PayoutMethodFilter!]
  or: [PayoutMethodFilter!]
  id: IDFilterComparison
  driverTransactions: PayoutMethodFilterDriverTransactionFilter
}

input PayoutMethodFilterDriverTransactionFilter {
  and: [PayoutMethodFilterDriverTransactionFilter!]
  or: [PayoutMethodFilterDriverTransactionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
}

input PayoutMethodSort {
  field: PayoutMethodSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PayoutMethodSortFields {
  id
}

type PayoutStatistics {
  pendingAmount: Float!
  lastPayoutAmount: Float!
  usersDefaultPayoutMethodStats: [PayoutMethodStats!]!
  currency: String!
}

type PayoutMethodStats {
  payoutMethod: PayoutMethod
  totalCount: Float!
}

type PayoutMethodDeleteResponse {
  id: ID
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: String
  mediaId: ID
  balance: Float
  enabled: Boolean
  currency: String
  name: String
  description: String
  type: PayoutMethodType
}

type PayoutAccountEdge {
  # The node containing the PayoutAccount
  node: PayoutAccount!

  # Cursor for this node.
  cursor: ConnectionCursor!
}

type PayoutSessionConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [PayoutSession!]!

  # Fetch total count of records
  totalCount: Int!
}

type PayoutSessionDriverTransactionsConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [DriverTransaction!]!

  # Fetch total count of records
  totalCount: Int!
}

type PayoutSessionDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type PayoutSessionDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  status: Int
  amount: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
}

type PayoutSessionDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type PayoutSessionDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
}

type PayoutSessionDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type PayoutSessionDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  status: TransactionStatus
  amount: Float
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
}

type PayoutSessionDriverTransactionsAggregateResponse {
  groupBy: PayoutSessionDriverTransactionsAggregateGroupBy
  count: PayoutSessionDriverTransactionsCountAggregate
  sum: PayoutSessionDriverTransactionsSumAggregate
  avg: PayoutSessionDriverTransactionsAvgAggregate
  min: PayoutSessionDriverTransactionsMinAggregate
  max: PayoutSessionDriverTransactionsMaxAggregate
}

type GiftCode {
  id: ID!
  usedAt: DateTime
  code: String!
  giftId: Float!
  riderTransaction: RiderTransaction
  driverTransaction: DriverTransaction
}

type GiftBatch {
  id: ID!
  name: String!
  currency: String!
  amount: Float!
  availableFrom: DateTime
  expireAt: DateTime
  giftCodesAggregate(
    # Filter to find records to aggregate on
    filter: GiftCodeAggregateFilter
  ): [GiftBatchGiftCodesAggregateResponse!]!
  giftCodes(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: GiftCodeFilter! = {}

    # Specify to sort results.
    sorting: [GiftCodeSort!]! = []
  ): GiftBatchGiftCodesConnection!
}

input GiftCodeAggregateFilter {
  and: [GiftCodeAggregateFilter!]
  or: [GiftCodeAggregateFilter!]
  id: IDFilterComparison
  usedAt: DateFieldComparison
}

input GiftCodeFilter {
  and: [GiftCodeFilter!]
  or: [GiftCodeFilter!]
  id: IDFilterComparison
  usedAt: DateFieldComparison
}

input GiftCodeSort {
  field: GiftCodeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum GiftCodeSortFields {
  id
  usedAt
}

type GiftBatchConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [GiftBatch!]!

  # Fetch total count of records
  totalCount: Int!
}

type GiftBatchGiftCodesConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [GiftCode!]!

  # Fetch total count of records
  totalCount: Int!
}

type GiftBatchGiftCodesAggregateGroupBy {
  id: ID
  usedAt: DateTime
}

type GiftBatchGiftCodesCountAggregate {
  id: Int
  usedAt: Int
}

type GiftBatchGiftCodesSumAggregate {
  id: Float
}

type GiftBatchGiftCodesAvgAggregate {
  id: Float
}

type GiftBatchGiftCodesMinAggregate {
  id: ID
  usedAt: DateTime
}

type GiftBatchGiftCodesMaxAggregate {
  id: ID
  usedAt: DateTime
}

type GiftBatchGiftCodesAggregateResponse {
  groupBy: GiftBatchGiftCodesAggregateGroupBy
  count: GiftBatchGiftCodesCountAggregate
  sum: GiftBatchGiftCodesSumAggregate
  avg: GiftBatchGiftCodesAvgAggregate
  min: GiftBatchGiftCodesMinAggregate
  max: GiftBatchGiftCodesMaxAggregate
}

type GiftCodeEdge {
  # The node containing the GiftCode
  node: GiftCode!

  # Cursor for this node.
  cursor: ConnectionCursor!
}

# SMS Provider
type SMSProvider {
  id: ID!
  name: String!
  type: SMSProviderType!
  isDefault: Boolean!
  accountId: String
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
}

# The type of the SMS provider
enum SMSProviderType {
  Firebase
  Twilio
  Plivo
  Pahappa
  BroadNet
  Vonage
  ClickSend
  Infobip
  MessageBird
}

type SMSProviderDeleteResponse {
  id: ID
  name: String
  type: SMSProviderType
  isDefault: Boolean
  accountId: String
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
}

type SMSProviderConnection {
  # Paging information
  pageInfo: OffsetPageInfo!

  # Array of nodes.
  nodes: [SMSProvider!]!

  # Fetch total count of records
  totalCount: Int!
}

type PlaceDTO {
  point: Point!
  title: String
  address: String!
}

input PointInput {
  lat: Float!
  lng: Float!
  heading: Int
}

input DistanceMultiplierInput {
  distanceFrom: Float!
  distanceTo: Float!
  multiply: Float!
}

input TimeMultiplierInput {
  startTime: String!
  endTime: String!
  multiply: Float!
}

input WeekdayMultiplierInput {
  weekday: Weekday!
  multiply: Float!
}

input DateRangeMultiplierInput {
  startDate: Float!
  endDate: Float!
  multiply: Float!
}

input AppConfigInfoInput {
  logo: String!
  name: String!
  color: String!
}

type Query {
  getDriversLocation(center: PointInput!, count: Int!): [OnlineDriver!]!
  getDriversLocationWithData(
    center: PointInput!
    count: Int!
  ): [OnlineDriverWithData!]!
  driverFeedbackParametersSummary(driverId: ID!): [FeedbackParameterAggregate!]!
  calculateFare(input: CalculateFareInput!): CalculateFareDTO!
  incomeChart(timeframe: ChartTimeframe!): [IncomeResultItem!]!
  requestChart(timeframe: ChartTimeframe!): [RequestResultItem!]!
  driverRegistrations(timeframe: ChartTimeframe!): [RegistrationResultItem!]!
  riderRegistrations(timeframe: ChartTimeframe!): [RegistrationResultItem!]!
  export(input: ExportArgs!): ExportResult!
  login(userName: String!, password: String!): TokenObject!
  me: Operator!
  supportedCurrencies: [String!]!
  payoutStatistics(currency: String): PayoutStatistics!
  getPlaces(
    keyword: String!
    location: PointInput

    # Search radius from location argument in meters
    radius: Int
    language: String
    provider: GeoProvider
    apiKey: String
  ): [PlaceDTO!]!
  reverseGeocode(
    location: PointInput!
    language: String
    provider: GeoProvider
    apiKey: String
  ): PlaceDTO!
  configInformation: ConfigInformation!
  licenseInformation: LicenseInformation
  currentConfiguration: CurrentConfiguration!
  service(
    # The id of the record to find.
    id: ID!
  ): Service!
  services(
    # Specify to filter the records returned.
    filter: ServiceFilter! = {}

    # Specify to sort results.
    sorting: [ServiceSort!]! = []
  ): [Service!]!
  serviceCategory(
    # The id of the record to find.
    id: ID!
  ): ServiceCategory!
  serviceCategories(
    # Specify to filter the records returned.
    filter: ServiceCategoryFilter! = {}

    # Specify to sort results.
    sorting: [ServiceCategorySort!]! = []
  ): [ServiceCategory!]!
  serviceOption(
    # The id of the record to find.
    id: ID!
  ): ServiceOption!
  serviceOptions(
    # Specify to filter the records returned.
    filter: ServiceOptionFilter! = {}

    # Specify to sort results.
    sorting: [ServiceOptionSort!]! = []
  ): [ServiceOption!]!
  zonePrice(
    # The id of the record to find.
    id: ID!
  ): ZonePrice!
  zonePrices(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: ZonePriceFilter! = {}

    # Specify to sort results.
    sorting: [ZonePriceSort!]! = []
  ): ZonePriceConnection!
  operatorRole(
    # The id of the record to find.
    id: ID!
  ): OperatorRole!
  operatorRoles(
    # Specify to filter the records returned.
    filter: OperatorRoleFilter! = {}

    # Specify to sort results.
    sorting: [OperatorRoleSort!]! = []
  ): [OperatorRole!]!
  operator(
    # The id of the record to find.
    id: ID!
  ): Operator!
  operators(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: OperatorFilter! = {}

    # Specify to sort results.
    sorting: [OperatorSort!]! = []
  ): OperatorConnection!
  rider(
    # The id of the record to find.
    id: ID!
  ): Rider!
  riders(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderFilter! = {}

    # Specify to sort results.
    sorting: [RiderSort!]! = []
  ): RiderConnection!
  riderWallet(
    # The id of the record to find.
    id: ID!
  ): RiderWallet!
  riderWallets(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderWalletFilter! = {}

    # Specify to sort results.
    sorting: [RiderWalletSort!]! = []
  ): RiderWalletConnection!
  riderTransaction(
    # The id of the record to find.
    id: ID!
  ): RiderTransaction!
  riderTransactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderTransactionFilter! = {}

    # Specify to sort results.
    sorting: [RiderTransactionSort!]! = []
  ): RiderTransactionConnection!
  riderAddress(
    # The id of the record to find.
    id: ID!
  ): RiderAddress!
  riderAddresses(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RiderAddressFilter! = {}

    # Specify to sort results.
    sorting: [RiderAddressSort!]! = []
  ): RiderAddressConnection!
  driverAggregate(
    # Filter to find records to aggregate on
    filter: DriverAggregateFilter
  ): [DriverAggregateResponse!]!
  driver(
    # The id of the record to find.
    id: ID!
  ): Driver!
  drivers(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DriverFilter! = {}

    # Specify to sort results.
    sorting: [DriverSort!]! = []
  ): DriverConnection!
  driverWallet(
    # The id of the record to find.
    id: ID!
  ): DriverWallet!
  driverWallets(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DriverWalletFilter! = {}

    # Specify to sort results.
    sorting: [DriverWalletSort!]! = []
  ): DriverWalletConnection!
  driverTransactionAggregate(
    # Filter to find records to aggregate on
    filter: DriverTransactionAggregateFilter
  ): [DriverTransactionAggregateResponse!]!
  driverTransaction(
    # The id of the record to find.
    id: ID!
  ): DriverTransaction!
  driverTransactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DriverTransactionFilter! = {}

    # Specify to sort results.
    sorting: [DriverTransactionSort!]! = []
  ): DriverTransactionConnection!
  fleet(
    # The id of the record to find.
    id: ID!
  ): Fleet!
  fleets(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FleetFilter! = {}

    # Specify to sort results.
    sorting: [FleetSort!]! = []
  ): FleetConnection!
  fleetWallet(
    # The id of the record to find.
    id: ID!
  ): FleetWallet!
  fleetWallets(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FleetWalletFilter! = {}

    # Specify to sort results.
    sorting: [FleetWalletSort!]! = []
  ): FleetWalletConnection!
  fleetTransaction(
    # The id of the record to find.
    id: ID!
  ): FleetTransaction!
  fleetTransactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FleetTransactionFilter! = {}

    # Specify to sort results.
    sorting: [FleetTransactionSort!]! = []
  ): FleetTransactionConnection!
  orderAggregate(
    # Filter to find records to aggregate on
    filter: OrderAggregateFilter
  ): [OrderAggregateResponse!]!
  order(
    # The id of the record to find.
    id: ID!
  ): Order!
  orders(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: OrderFilter! = {}

    # Specify to sort results.
    sorting: [OrderSort!]! = []
  ): OrderConnection!
  orderCancelReason(
    # The id of the record to find.
    id: ID!
  ): OrderCancelReason!
  orderCancelReasons(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: OrderCancelReasonFilter! = {}

    # Specify to sort results.
    sorting: [OrderCancelReasonSort!]! = []
  ): OrderCancelReasonConnection!
  announcement(
    # The id of the record to find.
    id: ID!
  ): Announcement!
  announcements(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: AnnouncementFilter! = {}

    # Specify to sort results.
    sorting: [AnnouncementSort!]! = []
  ): AnnouncementConnection!
  coupon(
    # The id of the record to find.
    id: ID!
  ): Coupon!
  coupons(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: CouponFilter! = {}

    # Specify to sort results.
    sorting: [CouponSort!]! = []
  ): CouponConnection!
  giftBatch(
    # The id of the record to find.
    id: ID!
  ): GiftBatch!
  giftBatches(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: GiftBatchFilter! = {}

    # Specify to sort results.
    sorting: [GiftBatchSort!]! = []
  ): GiftBatchConnection!
  providerTransaction(
    # The id of the record to find.
    id: ID!
  ): ProviderTransaction!
  providerTransactions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: ProviderTransactionFilter! = {}

    # Specify to sort results.
    sorting: [ProviderTransactionSort!]! = []
  ): ProviderTransactionConnection!
  providerWallet(
    # The id of the record to find.
    id: ID!
  ): ProviderWallet!
  providerWallets(
    # Specify to filter the records returned.
    filter: ProviderWalletFilter! = {}

    # Specify to sort results.
    sorting: [ProviderWalletSort!]! = []
  ): [ProviderWallet!]!
  regionAggregate(
    # Filter to find records to aggregate on
    filter: RegionAggregateFilter
  ): [RegionAggregateResponse!]!
  region(
    # The id of the record to find.
    id: ID!
  ): Region!
  regions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RegionFilter! = {}

    # Specify to sort results.
    sorting: [RegionSort!]! = []
  ): RegionConnection!
  paymentGateway(
    # The id of the record to find.
    id: ID!
  ): PaymentGateway!
  paymentGateways(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: PaymentGatewayFilter! = {}

    # Specify to sort results.
    sorting: [PaymentGatewaySort!]! = []
  ): PaymentGatewayConnection!
  carModel(
    # The id of the record to find.
    id: ID!
  ): CarModel!
  carModels(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: CarModelFilter! = {}

    # Specify to sort results.
    sorting: [CarModelSort!]! = []
  ): CarModelConnection!
  carColor(
    # The id of the record to find.
    id: ID!
  ): CarColor!
  carColors(
    # Specify to filter the records returned.
    filter: CarColorFilter! = {}

    # Specify to sort results.
    sorting: [CarColorSort!]! = []
  ): [CarColor!]!
  feedback(
    # The id of the record to find.
    id: ID!
  ): Feedback!
  feedbacks(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: FeedbackFilter! = {}

    # Specify to sort results.
    sorting: [FeedbackSort!]! = []
  ): FeedbackConnection!
  feedbackParameter(
    # The id of the record to find.
    id: ID!
  ): FeedbackParameter!
  feedbackParameters(
    # Specify to filter the records returned.
    filter: FeedbackParameterFilter! = {}

    # Specify to sort results.
    sorting: [FeedbackParameterSort!]! = []
  ): [FeedbackParameter!]!
  address(
    # The id of the record to find.
    id: ID!
  ): Address!
  addresses(
    # Limit or page results.
    paging: CursorPaging! = { first: 10 }

    # Specify to filter the records returned.
    filter: AddressFilter! = {}

    # Specify to sort results.
    sorting: [AddressSort!]! = []
  ): AddressConnection!
  payoutMethod(
    # The id of the record to find.
    id: ID!
  ): PayoutMethod!
  payoutMethods(
    # Specify to filter the records returned.
    filter: PayoutMethodFilter! = {}

    # Specify to sort results.
    sorting: [PayoutMethodSort!]! = []
  ): [PayoutMethod!]!
  payoutAccount(
    # The id of the record to find.
    id: ID!
  ): PayoutAccount!
  payoutSession(
    # The id of the record to find.
    id: ID!
  ): PayoutSession!
  payoutSessions(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: PayoutSessionFilter! = {}

    # Specify to sort results.
    sorting: [PayoutSessionSort!]! = []
  ): PayoutSessionConnection!
  distressSignalAggregate(
    # Filter to find records to aggregate on
    filter: DistressSignalAggregateFilter
  ): [DistressSignalAggregateResponse!]!
  distressSignal(
    # The id of the record to find.
    id: ID!
  ): DistressSignal!
  distressSignals(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: DistressSignalFilter! = {}

    # Specify to sort results.
    sorting: [DistressSignalSort!]! = []
  ): DistressSignalConnection!
  reward(
    # The id of the record to find.
    id: ID!
  ): Reward!
  rewards(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: RewardFilter! = {}

    # Specify to sort results.
    sorting: [RewardSort!]! = []
  ): RewardConnection!
  complaintAggregate(
    # Filter to find records to aggregate on
    filter: ComplaintAggregateFilter
  ): [ComplaintAggregateResponse!]!
  complaint(
    # The id of the record to find.
    id: ID!
  ): Complaint!
  complaints(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: ComplaintFilter! = {}

    # Specify to sort results.
    sorting: [ComplaintSort!]! = []
  ): ComplaintConnection!
  complaintActivity(
    # The id of the record to find.
    id: ID!
  ): ComplaintActivity!
  complaintActivities(
    # Specify to filter the records returned.
    filter: ComplaintActivityFilter! = {}

    # Specify to sort results.
    sorting: [ComplaintActivitySort!]! = []
  ): [ComplaintActivity!]!
  smsProvider(
    # The id of the record to find.
    id: ID!
  ): SMSProvider!
  smsProviders(
    # Limit or page results.
    paging: OffsetPaging! = { limit: 10 }

    # Specify to filter the records returned.
    filter: SMSProviderFilter! = {}

    # Specify to sort results.
    sorting: [SMSProviderSort!]! = []
  ): SMSProviderConnection!
}

input CalculateFareInput {
  riderId: ID!
  points: [PointInput!]!
}

enum ChartTimeframe {
  Daily
  Weekly
  Monthly
  Yearly
}

input ExportArgs {
  type: ExportType!
  table: ExportTable!
  filters: [ExportFilterArg!]
  sort: ExportSortArg
  relations: [String!]
}

enum ExportType {
  CSV
}

enum ExportTable {
  ProviderWallet
  DriverWallet
  RiderWallet
  FleetWallet
}

input ExportFilterArg {
  field: String!
  value: String!
}

input ExportSortArg {
  property: String!
  direction: SortDirection!
}

enum GeoProvider {
  GOOGLE
  MAPBOX
  NOMINATIM
}

input ServiceCategoryFilter {
  and: [ServiceCategoryFilter!]
  or: [ServiceCategoryFilter!]
  id: IDFilterComparison
}

input ServiceCategorySort {
  field: ServiceCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceCategorySortFields {
  id
}

input OperatorRoleFilter {
  and: [OperatorRoleFilter!]
  or: [OperatorRoleFilter!]
  id: IDFilterComparison
}

input OperatorRoleSort {
  field: OperatorRoleSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OperatorRoleSortFields {
  id
}

input OperatorFilter {
  and: [OperatorFilter!]
  or: [OperatorFilter!]
  id: IDFilterComparison
}

input OperatorSort {
  field: OperatorSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OperatorSortFields {
  id
}

input RiderFilter {
  and: [RiderFilter!]
  or: [RiderFilter!]
  id: IDFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
}

input RiderSort {
  field: RiderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderSortFields {
  id
  firstName
  lastName
  mobileNumber
}

input DriverAggregateFilter {
  and: [DriverAggregateFilter!]
  or: [DriverAggregateFilter!]
  id: IDFilterComparison
  fleetId: IDFilterComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  status: DriverStatusFilterComparison
}

input DriverStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: DriverStatus
  neq: DriverStatus
  gt: DriverStatus
  gte: DriverStatus
  lt: DriverStatus
  lte: DriverStatus
  like: DriverStatus
  notLike: DriverStatus
  iLike: DriverStatus
  notILike: DriverStatus
  in: [DriverStatus!]
  notIn: [DriverStatus!]
}

input DriverFilter {
  and: [DriverFilter!]
  or: [DriverFilter!]
  id: IDFilterComparison
  fleetId: IDFilterComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  status: DriverStatusFilterComparison
}

input DriverSort {
  field: DriverSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverSortFields {
  id
  fleetId
  lastName
  mobileNumber
  status
}

input OrderCancelReasonFilter {
  and: [OrderCancelReasonFilter!]
  or: [OrderCancelReasonFilter!]
  id: IDFilterComparison
}

input OrderCancelReasonSort {
  field: OrderCancelReasonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderCancelReasonSortFields {
  id
}

input AnnouncementFilter {
  and: [AnnouncementFilter!]
  or: [AnnouncementFilter!]
  id: IDFilterComparison
}

input AnnouncementSort {
  field: AnnouncementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AnnouncementSortFields {
  id
}

input CouponFilter {
  and: [CouponFilter!]
  or: [CouponFilter!]
  id: IDFilterComparison
}

input CouponSort {
  field: CouponSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CouponSortFields {
  id
}

input GiftBatchFilter {
  and: [GiftBatchFilter!]
  or: [GiftBatchFilter!]
  id: IDFilterComparison
}

input GiftBatchSort {
  field: GiftBatchSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum GiftBatchSortFields {
  id
}

input ProviderWalletFilter {
  and: [ProviderWalletFilter!]
  or: [ProviderWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
}

input ProviderWalletSort {
  field: ProviderWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProviderWalletSortFields {
  id
  balance
  currency
}

input RegionAggregateFilter {
  and: [RegionAggregateFilter!]
  or: [RegionAggregateFilter!]
  id: IDFilterComparison
  currency: StringFieldComparison
}

input PaymentGatewayFilter {
  and: [PaymentGatewayFilter!]
  or: [PaymentGatewayFilter!]
  id: IDFilterComparison
}

input PaymentGatewaySort {
  field: PaymentGatewaySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PaymentGatewaySortFields {
  id
}

input CarModelFilter {
  and: [CarModelFilter!]
  or: [CarModelFilter!]
  id: IDFilterComparison
}

input CarModelSort {
  field: CarModelSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CarModelSortFields {
  id
}

input CarColorFilter {
  and: [CarColorFilter!]
  or: [CarColorFilter!]
  id: IDFilterComparison
}

input CarColorSort {
  field: CarColorSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CarColorSortFields {
  id
}

input CursorPaging {
  # Paginate before opaque cursor
  before: ConnectionCursor

  # Paginate after opaque cursor
  after: ConnectionCursor

  # Paginate first
  first: Int

  # Paginate last
  last: Int
}

input AddressFilter {
  and: [AddressFilter!]
  or: [AddressFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input AddressSort {
  field: AddressSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AddressSortFields {
  id
  riderId
}

input PayoutSessionFilter {
  and: [PayoutSessionFilter!]
  or: [PayoutSessionFilter!]
  id: IDFilterComparison
}

input PayoutSessionSort {
  field: PayoutSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PayoutSessionSortFields {
  id
}

input DistressSignalAggregateFilter {
  and: [DistressSignalAggregateFilter!]
  or: [DistressSignalAggregateFilter!]
  id: IDFilterComparison
  status: SOSStatusFilterComparison
}

input SOSStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SOSStatus
  neq: SOSStatus
  gt: SOSStatus
  gte: SOSStatus
  lt: SOSStatus
  lte: SOSStatus
  like: SOSStatus
  notLike: SOSStatus
  iLike: SOSStatus
  notILike: SOSStatus
  in: [SOSStatus!]
  notIn: [SOSStatus!]
}

input DistressSignalFilter {
  and: [DistressSignalFilter!]
  or: [DistressSignalFilter!]
  id: IDFilterComparison
  status: SOSStatusFilterComparison
}

input DistressSignalSort {
  field: DistressSignalSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DistressSignalSortFields {
  id
  status
}

input RewardFilter {
  and: [RewardFilter!]
  or: [RewardFilter!]
  id: IDFilterComparison
}

input RewardSort {
  field: RewardSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RewardSortFields {
  id
}

input SMSProviderFilter {
  and: [SMSProviderFilter!]
  or: [SMSProviderFilter!]
  id: IDFilterComparison
}

input SMSProviderSort {
  field: SMSProviderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SMSProviderSortFields {
  id
}

type Mutation {
  updatePassword(input: UpdatePasswordInput!): Operator!
  createRiderTransaction(input: RiderTransactionInput!): RiderWallet!
  deleteOneRider(id: ID!): Rider!
  createDriverTransaction(input: DriverTransactionInput!): DriverWallet!
  deleteOneDriver(id: ID!): Driver!
  createFleetTransaction(input: FleetTransactionInput!): FleetWallet!
  createOrder(input: CreateOrderInput!): Order!
  cancelOrder(orderId: ID!): Order!
  assignDriverToOrder(orderId: ID!, driverId: ID!): Order!
  createGiftCardBatch(input: CreateGiftBatchInput!): GiftBatch!
  exportGiftCardBatch(batchId: ID!): String!
  createPayoutSession(input: CreatePayoutSessionInput!): PayoutSession!
  exportSessionToCsv(input: ExportSessionToCsvInput!): String!
  runAutoPayout(input: RunAutoPayoutInput!): Boolean!
  manualPayout(input: ManualPayoutInput!): DriverTransaction!
  updatePayoutSession(id: ID!, input: UpdatePayoutSessionInput!): PayoutSession!
  updateConfigurations(input: UpdateConfigInputV2!): UpdateConfigResult!
  updatePurchaseCode(
    purchaseCode: String!
    email: String
  ): UpdatePurchaseCodeResult!
  updateMapsAPIKey(backend: String!, adminPanel: String!): UpdateConfigResult!
  updateFirebase(keyFileName: String!): UpdateConfigResult!
  disablePreviousServer(ip: String!, purchaseCode: String): UpdateConfigResult!
  saveConfiguration(input: UpdateConfigInput!): CurrentConfiguration!
  markSMSProviderAsDefault(id: ID!): SMSProvider!
  addRegionsToService(input: AddRegionsToServiceInput!): Service!
  setRegionsOnService(input: SetRegionsOnServiceInput!): Service!
  addOptionsToService(input: AddOptionsToServiceInput!): Service!
  setOptionsOnService(input: SetOptionsOnServiceInput!): Service!
  createOneService(input: CreateOneServiceInput!): Service!
  updateOneService(input: UpdateOneServiceInput!): Service!
  deleteOneService(input: DeleteOneServiceInput!): ServiceDeleteResponse!
  createOneServiceCategory(
    input: CreateOneServiceCategoryInput!
  ): ServiceCategory!
  updateOneServiceCategory(
    input: UpdateOneServiceCategoryInput!
  ): ServiceCategory!
  deleteOneServiceCategory(
    input: DeleteOneServiceCategoryInput!
  ): ServiceCategoryDeleteResponse!
  createOneServiceOption(input: CreateOneServiceOptionInput!): ServiceOption!
  updateOneServiceOption(input: UpdateOneServiceOptionInput!): ServiceOption!
  deleteOneServiceOption(
    input: DeleteOneServiceOptionInput!
  ): ServiceOptionDeleteResponse!
  addFleetsToZonePrice(input: AddFleetsToZonePriceInput!): ZonePrice!
  setFleetsOnZonePrice(input: SetFleetsOnZonePriceInput!): ZonePrice!
  addServicesToZonePrice(input: AddServicesToZonePriceInput!): ZonePrice!
  setServicesOnZonePrice(input: SetServicesOnZonePriceInput!): ZonePrice!
  createOneZonePrice(input: CreateOneZonePriceInput!): ZonePrice!
  updateOneZonePrice(input: UpdateOneZonePriceInput!): ZonePrice!
  deleteOneZonePrice(input: DeleteOneZonePriceInput!): ZonePriceDeleteResponse!
  createOneOperatorRole(input: CreateOneOperatorRoleInput!): OperatorRole!
  updateOneOperatorRole(input: UpdateOneOperatorRoleInput!): OperatorRole!
  createOneOperator(input: CreateOneOperatorInput!): Operator!
  updateOneOperator(input: UpdateOneOperatorInput!): Operator!
  createOneRider(input: CreateOneRiderInput!): Rider!
  updateOneRider(input: UpdateOneRiderInput!): Rider!
  createOneRiderTransaction(
    input: CreateOneRiderTransactionInput!
  ): RiderTransaction!
  createOneRiderAddress(input: CreateOneRiderAddressInput!): RiderAddress!
  updateOneRiderAddress(input: UpdateOneRiderAddressInput!): RiderAddress!
  updateManyRiderAddresses(
    input: UpdateManyRiderAddressesInput!
  ): UpdateManyResponse!
  addEnabledServicesToDriver(input: AddEnabledServicesToDriverInput!): Driver!
  setEnabledServicesOnDriver(input: SetEnabledServicesOnDriverInput!): Driver!
  createOneDriver(input: CreateOneDriverInput!): Driver!
  updateOneDriver(input: UpdateOneDriverInput!): Driver!
  createOneDriverTransaction(
    input: CreateOneDriverTransactionInput!
  ): DriverTransaction!
  createOneFleet(input: CreateOneFleetInput!): Fleet!
  updateOneFleet(input: UpdateOneFleetInput!): Fleet!
  createOneOrderCancelReason(
    input: CreateOneOrderCancelReasonInput!
  ): OrderCancelReason!
  updateOneOrderCancelReason(
    input: UpdateOneOrderCancelReasonInput!
  ): OrderCancelReason!
  deleteOneOrderCancelReason(
    input: DeleteOneOrderCancelReasonInput!
  ): OrderCancelReasonDeleteResponse!
  createOneAnnouncement(input: CreateOneAnnouncementInput!): Announcement!
  updateOneAnnouncement(input: UpdateOneAnnouncementInput!): Announcement!
  deleteOneAnnouncement(
    input: DeleteOneAnnouncementInput!
  ): AnnouncementDeleteResponse!
  createOneCoupon(input: CreateOneCouponInput!): Coupon!
  updateOneCoupon(input: UpdateOneCouponInput!): Coupon!
  deleteOneCoupon(input: DeleteOneCouponInput!): CouponDeleteResponse!
  createOneProviderTransaction(
    input: CreateOneProviderTransactionInput!
  ): ProviderTransaction!
  createOneRegion(input: CreateOneRegionInput!): Region!
  updateOneRegion(input: UpdateOneRegionInput!): Region!
  deleteOneRegion(input: DeleteOneRegionInput!): RegionDeleteResponse!
  createOnePaymentGateway(input: CreateOnePaymentGatewayInput!): PaymentGateway!
  updateOnePaymentGateway(input: UpdateOnePaymentGatewayInput!): PaymentGateway!
  createOneCarModel(input: CreateOneCarModelInput!): CarModel!
  updateOneCarModel(input: UpdateOneCarModelInput!): CarModel!
  deleteOneCarModel(input: DeleteOneCarModelInput!): CarModelDeleteResponse!
  createOneCarColor(input: CreateOneCarColorInput!): CarColor!
  updateOneCarColor(input: UpdateOneCarColorInput!): CarColor!
  deleteOneCarColor(input: DeleteOneCarColorInput!): CarColorDeleteResponse!
  updateOneFeedback(input: UpdateOneFeedbackInput!): Feedback!
  createOneFeedbackParameter(
    input: CreateOneFeedbackParameterInput!
  ): FeedbackParameter!
  updateOneFeedbackParameter(
    input: UpdateOneFeedbackParameterInput!
  ): FeedbackParameter!
  deleteOneFeedbackParameter(
    input: DeleteOneFeedbackParameterInput!
  ): FeedbackParameterDeleteResponse!
  createOnePayoutMethod(input: CreateOnePayoutMethodInput!): PayoutMethod!
  updateOnePayoutMethod(input: UpdateOnePayoutMethodInput!): PayoutMethod!
  deleteOnePayoutMethod(
    input: DeleteOnePayoutMethodInput!
  ): PayoutMethodDeleteResponse!
  createOneSOSActivity(input: CreateOneSOSActivityInput!): SOSActivity!
  createOneReward(input: CreateOneRewardInput!): Reward!
  updateOneReward(input: UpdateOneRewardInput!): Reward!
  deleteOneReward(input: DeleteOneRewardInput!): RewardDeleteResponse!
  updateOneComplaint(input: UpdateOneComplaintInput!): Complaint!
  createOneComplaintActivity(
    input: CreateOneComplaintActivityInput!
  ): ComplaintActivity!
  createManyComplaintActivities(
    input: CreateManyComplaintActivitiesInput!
  ): [ComplaintActivity!]!
  createOneSMSProvider(input: CreateOneSMSProviderInput!): SMSProvider!
  createManySMSProviders(input: CreateManySMSProvidersInput!): [SMSProvider!]!
  updateOneSMSProvider(input: UpdateOneSMSProviderInput!): SMSProvider!
  updateManySMSProviders(
    input: UpdateManySMSProvidersInput!
  ): UpdateManyResponse!
  deleteOneSMSProvider(
    input: DeleteOneSMSProviderInput!
  ): SMSProviderDeleteResponse!
  deleteManySMSProviders(
    input: DeleteManySMSProvidersInput!
  ): DeleteManyResponse!
}

input UpdatePasswordInput {
  oldPassword: String!
  newPasswod: String!
}

input RiderTransactionInput {
  riderId: ID!
  action: TransactionAction!
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
}

input DriverTransactionInput {
  driverId: ID!
  action: TransactionAction!
  deductType: DriverDeductTransactionType
  rechargeType: DriverRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
}

input FleetTransactionInput {
  fleetId: ID!
  action: TransactionAction!
  deductType: String
  rechargeType: String
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
}

input CreateOrderInput {
  riderId: ID!
  serviceId: ID!
  intervalMinutes: Int!
  points: [PointInput!]!
  addresses: [String!]!
}

input CreateGiftBatchInput {
  name: String!
  currency: String!
  amount: Float!
  availableFrom: DateTime
  expireAt: DateTime
  quantity: Float!
}

input CreatePayoutSessionInput {
  payoutMethodIds: [ID!]!
  minimumAmount: Float!
  currency: String!
  description: String
}

input ExportSessionToCsvInput {
  payoutSessionId: ID!
  payoutMethodId: ID
}

input RunAutoPayoutInput {
  payoutSessionId: ID!
  payoutMethodId: ID!
}

input ManualPayoutInput {
  driverTransactionId: ID!
  transactionNumber: String!
  description: String
}

input UpdatePayoutSessionInput {
  status: PayoutSessionStatus!
}

input UpdateConfigInputV2 {
  taxi: AppConfigInfoInput
  shop: AppConfigInfoInput
  parking: AppConfigInfoInput
  phoneNumber: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  adminPanelAPIKey: String!
  backendMapsAPIKey: String!
  companyLogo: String!
  companyName: String!
  mysqlHost: String!
  mysqlPort: String!
  mysqlUser: String!
  mysqlPassword: String!
  mysqlDatabase: String!
  redisHost: String!
  redisPort: String!
  redisPassword: String!
  firebaseProjectPrivateKey: String!
}

input UpdateConfigInput {
  backendMapsAPIKey: String
  adminPanelAPIKey: String
  twilioAccountSid: String
  twilioAuthToken: String
  twilioFromNumber: String
  twilioVerificationCodeSMSTemplate: String
}

input AddRegionsToServiceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input SetRegionsOnServiceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input AddOptionsToServiceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input SetOptionsOnServiceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input CreateOneServiceInput {
  # The record to create
  service: ServiceInput!
}

input ServiceInput {
  personCapacity: Int
  categoryId: ID!
  searchRadius: Int!
  providerSharePercent: Int!
  maximumDestinationDistance: Int!
  mediaId: ID!
  name: String!
  description: String
  baseFare: Float!
  roundingFactor: Float
  perHundredMeters: Float!
  perMinuteDrive: Float!
  perMinuteWait: Float!
  prepayPercent: Float!
  minimumFee: Float!
  paymentMethod: ServicePaymentMethod!
  cancellationTotalFee: Float!
  cancellationDriverShare: Float!
  providerShareFlat: Float!
  twoWayAvailable: Boolean!
  timeMultipliers: [TimeMultiplierInput!]!
  distanceMultipliers: [DistanceMultiplierInput!]!
  weekdayMultipliers: [WeekdayMultiplierInput!]!
  dateRangeMultipliers: [DateRangeMultiplierInput!]!
}

input UpdateOneServiceInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: ServiceInput!
}

input DeleteOneServiceInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneServiceCategoryInput {
  # The record to create
  serviceCategory: ServiceCategoryInput!
}

input ServiceCategoryInput {
  name: String!
  enabled: Boolean
}

input UpdateOneServiceCategoryInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: ServiceCategoryInput!
}

input DeleteOneServiceCategoryInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneServiceOptionInput {
  # The record to create
  serviceOption: ServiceOptionInput!
}

input ServiceOptionInput {
  name: String!
  type: ServiceOptionType!
  additionalFee: Float
  icon: ServiceOptionIcon!
}

input UpdateOneServiceOptionInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: ServiceOptionInput!
}

input DeleteOneServiceOptionInput {
  # The id of the record to delete.
  id: ID!
}

input AddFleetsToZonePriceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input SetFleetsOnZonePriceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input AddServicesToZonePriceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input SetServicesOnZonePriceInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input CreateOneZonePriceInput {
  # The record to create
  zonePrice: ZonePriceInput!
}

input ZonePriceInput {
  name: String!
  from: [[PointInput!]!]!
  to: [[PointInput!]!]!
  cost: Float!
  timeMultipliers: [TimeMultiplierInput!]!
}

input UpdateOneZonePriceInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: ZonePriceInput!
}

input DeleteOneZonePriceInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneOperatorRoleInput {
  # The record to create
  operatorRole: OperatorRoleInput!
}

input OperatorRoleInput {
  title: String!
  permissions: [OperatorPermission!]!
}

input UpdateOneOperatorRoleInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: OperatorRoleInput!
}

input CreateOneOperatorInput {
  # The record to create
  operator: CreateOperatorInput!
}

input CreateOperatorInput {
  roleId: ID!
  firstName: String
  lastName: String
  userName: String!
  password: String!
  mobileNumber: String!
  email: String
}

input UpdateOneOperatorInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateOperator!
}

input UpdateOperator {
  id: ID
  roleId: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
}

input CreateOneRiderInput {
  # The record to create
  rider: RiderInput!
}

input RiderInput {
  status: RiderStatus
  firstName: String
  lastName: String
  mobileNumber: String
  registrationTimestamp: DateTime
  email: String
  gender: Gender
  isResident: Boolean
  idNumber: String
}

input UpdateOneRiderInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: RiderInput!
}

input CreateOneRiderTransactionInput {
  # The record to create
  riderTransaction: CreateRiderTransaction!
}

input CreateRiderTransaction {
  id: ID!
  createdAt: DateTime!
  amount: Float!
  currency: String!
  riderId: ID!
  paymentGatewayId: ID
  operatorId: ID
  requestId: ID
  action: TransactionAction!
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus!
  refrenceNumber: String
  description: String
}

input CreateOneRiderAddressInput {
  # The record to create
  riderAddress: CreateRiderAddress!
}

input CreateRiderAddress {
  id: ID!
  riderId: ID!
  type: RiderAddressType!
  title: String!
  details: String
  location: PointInput!
}

input UpdateOneRiderAddressInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateRiderAddress!
}

input UpdateRiderAddress {
  id: ID
  riderId: ID
  type: RiderAddressType
  title: String
  details: String
  location: PointInput
}

input UpdateManyRiderAddressesInput {
  # Filter used to find fields to update
  filter: RiderAddressUpdateFilter!

  # The update to apply to all records found using the filter
  update: UpdateRiderAddress!
}

input RiderAddressUpdateFilter {
  and: [RiderAddressUpdateFilter!]
  or: [RiderAddressUpdateFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input AddEnabledServicesToDriverInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input SetEnabledServicesOnDriverInput {
  # The id of the record.
  id: ID!

  # The ids of the relations.
  relationIds: [ID!]!
}

input CreateOneDriverInput {
  # The record to create
  driver: UpdateDriverInput!
}

input UpdateDriverInput {
  fleetId: ID
  carId: ID
  carColorId: ID
  carProductionYear: Int
  mediaId: ID
  mobileNumber: String
  firstName: String
  lastName: String
  certificateNumber: String
  email: String
  carPlate: String
  status: DriverStatus
  gender: Gender
  accountNumber: String
  bankName: String
  bankRoutingNumber: String
  bankSwift: String
  address: String
  softRejectionNote: String
}

input UpdateOneDriverInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateDriverInput!
}

input CreateOneDriverTransactionInput {
  # The record to create
  driverTransaction: DriverTransactionInput!
}

input CreateOneFleetInput {
  # The record to create
  fleet: FleetInput!
}

input FleetInput {
  name: String!
  phoneNumber: String!
  mobileNumber: String!
  userName: String!
  password: String!
  accountNumber: String!
  commissionSharePercent: Float!
  commissionShareFlat: Float!
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[PointInput!]!]
}

input UpdateOneFleetInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: FleetInput!
}

input CreateOneOrderCancelReasonInput {
  # The record to create
  orderCancelReason: OrderCancelReasonInput!
}

input OrderCancelReasonInput {
  isEnabled: Boolean
  userType: AnnouncementUserType
  title: String
}

input UpdateOneOrderCancelReasonInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: OrderCancelReasonInput!
}

input DeleteOneOrderCancelReasonInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneAnnouncementInput {
  # The record to create
  announcement: AnnouncementInput!
}

input AnnouncementInput {
  title: String!
  description: String!
  url: String
  userType: [AnnouncementUserType!]!
  startAt: DateTime!
  expireAt: DateTime!
}

input UpdateOneAnnouncementInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: AnnouncementInput!
}

input DeleteOneAnnouncementInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneCouponInput {
  # The record to create
  coupon: CouponInput!
}

input CouponInput {
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  discountPercent: Int!
  discountFlat: Int!
  code: String!
  title: String!
  description: String!
  minimumCost: Float!
  maximumCost: Float!
  startAt: DateTime!
  expireAt: DateTime!
  creditGift: Float!
  isEnabled: Boolean!
  isFirstTravelOnly: Boolean!
}

input UpdateOneCouponInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: CouponInput!
}

input DeleteOneCouponInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneProviderTransactionInput {
  # The record to create
  providerTransaction: ProviderTransactionInput!
}

input ProviderTransactionInput {
  action: TransactionAction!
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  createdAt: DateTime!
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
}

input CreateOneRegionInput {
  # The record to create
  region: RegionInput!
}

input RegionInput {
  name: String!
  currency: String!
  enabled: Boolean!
  location: [[PointInput!]!]!
}

input UpdateOneRegionInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: RegionInput!
}

input DeleteOneRegionInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOnePaymentGatewayInput {
  # The record to create
  paymentGateway: PaymentGatewayInput!
}

input PaymentGatewayInput {
  enabled: Boolean!
  title: String!
  type: PaymentGatewayType!
  publicKey: String
  privateKey: String!
  merchantId: String
  saltKey: String
  mediaId: Float
}

input UpdateOnePaymentGatewayInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: PaymentGatewayInput!
}

input CreateOneCarModelInput {
  # The record to create
  carModel: CarModelInput!
}

input CarModelInput {
  name: String!
}

input UpdateOneCarModelInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: CarModelInput!
}

input DeleteOneCarModelInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneCarColorInput {
  # The record to create
  carColor: CarColorInput!
}

input CarColorInput {
  name: String!
}

input UpdateOneCarColorInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: CarColorInput!
}

input DeleteOneCarColorInput {
  # The id of the record to delete.
  id: ID!
}

input UpdateOneFeedbackInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateFeedback!
}

input UpdateFeedback {
  id: ID
  score: Int
  driverId: ID
  requestId: ID
  reviewTimestamp: DateTime
  description: String
}

input CreateOneFeedbackParameterInput {
  # The record to create
  feedbackParameter: FeedbackParameterInput!
}

input FeedbackParameterInput {
  title: String!
  isGood: Boolean!
}

input UpdateOneFeedbackParameterInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: FeedbackParameterInput!
}

input DeleteOneFeedbackParameterInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOnePayoutMethodInput {
  # The record to create
  payoutMethod: CreatePayoutMethodInput!
}

input CreatePayoutMethodInput {
  enabled: Boolean
  name: String!
  description: String!
  currency: String!
  type: PayoutMethodType!
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: String
  mediaId: Float
  deletedAt: DateTime
}

input UpdateOnePayoutMethodInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: CreatePayoutMethodInput!
}

input DeleteOnePayoutMethodInput {
  # The id of the record to delete.
  id: ID!
}

input CreateOneSOSActivityInput {
  # The record to create
  sOSActivity: CreateSOSAcitivtyInput!
}

input CreateSOSAcitivtyInput {
  sosId: ID!
  action: SOSActivityAction!
  note: String
}

input CreateOneRewardInput {
  # The record to create
  reward: CreateReward!
}

input CreateReward {
  id: ID!
  title: String!
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType!
  beneficiary: RewardBeneficiary!
  event: RewardEvent!
  creditGift: Float!
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

input UpdateOneRewardInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateReward!
}

input UpdateReward {
  id: ID
  title: String
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType
  beneficiary: RewardBeneficiary
  event: RewardEvent
  creditGift: Float
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

input DeleteOneRewardInput {
  # The id of the record to delete.
  id: ID!
}

input UpdateOneComplaintInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: UpdateComplaint!
}

input UpdateComplaint {
  id: ID
  status: ComplaintStatus
  requestId: ID
  inscriptionTimestamp: DateTime
  requestedByDriver: Boolean
  subject: String
  content: String
}

input CreateOneComplaintActivityInput {
  # The record to create
  complaintActivity: CreateComplaintActivity!
}

input CreateComplaintActivity {
  id: ID!
  complaintId: ID!
  type: ComplaintActivityType!
  comment: String
}

input CreateManyComplaintActivitiesInput {
  # Array of records to create
  complaintActivities: [CreateComplaintActivity!]!
}

input CreateOneSMSProviderInput {
  # The record to create
  sMSProvider: SMSProviderInput!
}

input SMSProviderInput {
  name: String
  type: SMSProviderType
  isDefault: Boolean
  accountId: String
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
}

input CreateManySMSProvidersInput {
  # Array of records to create
  sMSProviders: [SMSProviderInput!]!
}

input UpdateOneSMSProviderInput {
  # The id of the record to update
  id: ID!

  # The update to apply.
  update: SMSProviderInput!
}

input UpdateManySMSProvidersInput {
  # Filter used to find fields to update
  filter: SMSProviderUpdateFilter!

  # The update to apply to all records found using the filter
  update: SMSProviderInput!
}

input SMSProviderUpdateFilter {
  and: [SMSProviderUpdateFilter!]
  or: [SMSProviderUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneSMSProviderInput {
  # The id of the record to delete.
  id: ID!
}

input DeleteManySMSProvidersInput {
  # Filter to find records to delete
  filter: SMSProviderDeleteFilter!
}

input SMSProviderDeleteFilter {
  and: [SMSProviderDeleteFilter!]
  or: [SMSProviderDeleteFilter!]
  id: IDFilterComparison
}

type Subscription {
  orderUpdated(orderId: ID!): Order!
  sosCreated: DistressSignal!
  complaintCreated: Complaint!
}
